#!/usr/bin/env bash
# This file is autogenerated by lab/permanent-scripts/pack. Usage:
# script=https://raw.githubusercontent.com/devizer/test-and-build/master/install-build-tools-bundle.sh; (wget -q -nv --no-check-certificate -O - $script 2>/dev/null || curl -ksSL $script) | bash

TARGET_DIR=${TARGET_DIR:-/usr/local/bin}
function install_build_tools_bundle() {



# Drop-FS-Cache
if [[ -d ${TARGET_DIR} ]]; then
  echo -e "#!/usr/bin/env bash
usystem=\"\$(uname -s)\"
if [[ \"\$usystem\" == \"Linux\" ]]; then
  sync; sudo sync; echo 3 | sudo tee /proc/sys/vm/drop_caches > /dev/null
elif [[ \"\$usystem\" == \"Darwin\" ]]; then
  sync; sudo sync; sudo purge
else 
  echo 'Drop-FS-Cache: Only Linux and macOS are currently supported'
fi


" 2>/dev/null >${TARGET_DIR}/Drop-FS-Cache ||
  echo -e "#!/usr/bin/env bash
usystem=\"\$(uname -s)\"
if [[ \"\$usystem\" == \"Linux\" ]]; then
  sync; sudo sync; echo 3 | sudo tee /proc/sys/vm/drop_caches > /dev/null
elif [[ \"\$usystem\" == \"Darwin\" ]]; then
  sync; sudo sync; sudo purge
else 
  echo 'Drop-FS-Cache: Only Linux and macOS are currently supported'
fi


" | sudo tee ${TARGET_DIR}/Drop-FS-Cache >/dev/null;
  if [[ -f ${TARGET_DIR}/Drop-FS-Cache ]]; then 
      chmod +x ${TARGET_DIR}/Drop-FS-Cache >/dev/null 2>&1 || sudo chmod +x ${TARGET_DIR}/Drop-FS-Cache
  	echo "OK: ${TARGET_DIR}/Drop-FS-Cache"; 
  else "Error: Unable to extract ${TARGET_DIR}/Drop-FS-Cache"; fi
else 
  echo "Skipping ${TARGET_DIR}/Drop-FS-Cache: directory does not exists"
fi


# File-IO-Benchmark
if [[ -d ${TARGET_DIR} ]]; then
  echo -e "#!/usr/bin/env bash

# Possible \$FILE_IO_BENCHMARK_OPTIONS: --eta=always --time_based

function Has_Unicode() {
  if [[ -n \"\${FORCE_UNICODE:-}\" ]]; then echo \"true\"; return; fi
  if [[ -n \"\${DISABLE_UNICODE:-}\" ]]; then echo \"false\"; return; fi
  if [[ -z \"\${hasUnicode:-}\" ]]; then
    if [[ \"\$(locale charmap 2>/dev/null)\" == \"UTF\"* ]]; then
      hasUnicode=\"true\"
    else
      hasUnicode=\"false\"
    fi
  fi
  echo \$hasUnicode
}

function Header() {
  local char_arrow='>'; local char_dash='-'
  if [[ \"\$(Has_Unicode)\" == \"true\" ]]; then
    char_arrow='\x5CU27A4'; char_dash='\x5CU2500'
  fi
  local txt=\$1
  local length=\${#txt}
  local border=\"\${char_dash}\${char_dash}\${char_dash}\"; while [[ \$length -gt 0 ]]; do border=\"\${char_dash}\${border}\"; length=\$((length-1)); done
  # if [[ \"\${NEXT_HEADER:-}\" == \"\" ]]; then NEXT_HEADER=true; else echo \"\"; fi
  tput bold 2>/dev/null || true
  echo -e \"\${char_arrow} \${txt}\"; echo -e \$border
  tput sgr0 2>/dev/null || true
}

if [[ \"\$1\" == \"\" || \"\$1\" == \"--help\" ]]; then
echo \"Usage: File-IO-Benchmark 'Root FS' / 1G 30 5
here 1G - working set size
     30 - test duration, in seconds
     5  - ramp duration (for VM, raids and ssd 30 seconds is recommended)
Possible \x5C\$FILE_IO_BENCHMARK_OPTIONS: --eta=always --time_based
\"
exit 0;
fi

CAPTION=\$1
DISK=\$2
SIZE=\$3
DURATION=\$4
RAMP=\$5

CAPTION=\${CAPTION:-Current Folder}
DISK=\${DISK:-\$(pwd)}
SIZE=\${SIZE:-1G}
DURATION=\${DURATION:-30}
RAMP=\${RAMP:-5}

export SYSTEM_VERSION_COMPAT=\${SYSTEM_VERSION_COMPAT:-1}
OS_X_VER=\$(sw_vers 2>/dev/null | grep BuildVer | awk '{print \$2}' | cut -c1-2 || true); OS_X_VER=\$((OS_X_VER-4)); [ \"\$OS_X_VER\" -gt 0 ] || unset OS_X_VER

# DETECT io engine
if [[ -n \"\$OS_X_VER\" ]] && [[ \"\$OS_X_VER\" -gt 0 ]]; then ioengine=posixaio; else ioengine=libaio; fi
if [[ \"\$(uname -r)\" == *\"Microsoft\" ]] || [[ \"\$(uname -s)\" == \"MINGW\"* ]]; then ioengine=windowsaio; fi
if [[ -n \"\$FILE_IO_BENCHMARK_ENGINE\" ]]; then ioengine=\$FILE_IO_BENCHMARK_ENGINE; fi

# install fio
 if [[ \"\$(command -v fio 2>/dev/null)\" == \"\" ]]; then
   if [[ \"\$(command -v apt-get 2>/dev/null)\" != \"\" ]]; then
     echo \"Installing fio using apt-get\"
     sudo apt-get install -yqq fio >/tmp/fio-install.log 2>&1 || sudo apt-get install -yqq fio >/tmp/fio-install.log 2>&1 || sudo cat /tmp/fio-install.log
   elif [[ \"\$(command -v yum 2>/dev/null)\" != \"\" ]]; then
     echo \"Installing fio and toilet using yum\"
     sudo yum install -y fio >/tmp/fio-install.log 2>&1 || sudo yum install -y fio >/tmp/fio-install.log 2>&1 || sudo cat /tmp/fio-install.log
   fi
 fi

# check libaio support
pushd \"\$DISK\" >/dev/null
if [[ \"\$ioengine\" == libaio ]]; then
if fio --name=CHECK_LIBAIO --ioengine=\$ioengine --gtod_reduce=1 --filename=fiotest.tmp --bs=4k --size=64k --runtime=1 --readwrite=randread >/dev/null 2>&1; then
  ioengine=libaio
else
  ioengine=posixaio
fi
fi

# check DIRECT IO
direct=0; direct_info=\"Direct IO: [Absent]\"
if fio --name=CHECK_DIRECT_IO --ioengine=\$ioengine --direct=1 --gtod_reduce=1 --filename=fiotest.tmp --bs=4k --size=64k --runtime=1 --readwrite=randread >/dev/null 2>&1; then
  direct=1; direct_info=\"Direct IO: [Present]\"
fi
if [[ -f fiotest.tmp ]]; then rm -f fiotest.tmp; fi
popd >/dev/null

info=\"Detected IO Engine: [\${ioengine}]. \$direct_info\"
echo \"\$info\" # Header \"\$info\"

errorCode=1; exitCode=0;

 function go_fio_1test() {
   local cmd=\$1
   local disk=\$2
   local caption=\"\$3\"
   pushd \"\$disk\" >/dev/null
   Header \"\$caption (\$(pwd))\"
   echo \"Benchmark '\$(pwd)' folder using '\$cmd' test during \$DURATION seconds and heating \$RAMP secs, size is \$SIZE\"
   if [[ \$cmd == \"rand\"* ]]; then
      fio_shell_cmd=\"fio \$FILE_IO_BENCHMARK_OPTIONS --name=RUN_\$cmd --randrepeat=1 --ioengine=\$ioengine --direct=\$direct --gtod_reduce=1 --filename=fiotest.tmp --bs=4k --iodepth=64 --size=\$SIZE --runtime=\$DURATION --ramp_time=\$RAMP --readwrite=\$cmd\"
   else
      fio_shell_cmd=\"fio \$FILE_IO_BENCHMARK_OPTIONS --name=RUN_\$cmd --ioengine=\$ioengine --direct=\$direct --gtod_reduce=1 --filename=fiotest.tmp --bs=1024k --size=\$SIZE --runtime=\$DURATION --ramp_time=\$RAMP --readwrite=\$cmd\"
   fi
   if [[ -n \"\$FILE_IO_BENCHMARK_DUMP_FOLDER\" ]]; then
     fio_version=\"\$(fio --version)\"
     fio_version=\"\${fio_version:-unknown}\"
     mkdir -p \"\$FILE_IO_BENCHMARK_DUMP_FOLDER/\$fio_version\"
     fio_shell_cmd=\"\$fio_shell_cmd | tee \x5C\"\$FILE_IO_BENCHMARK_DUMP_FOLDER/\$fio_version/\$cmd.log\x5C\"\"
   fi
   set -o pipefail
   eval \$fio_shell_cmd
   if [[ \$? == 0 ]]; then isError=0; else isError=1; fi
   exitCode=\$((isError*errorCode + exitCode)); errorCode=\$((errorCode*2))
   popd >/dev/null
   echo \"\"
 }
 
 function go_fio_4tests() {
   local disk=\$1
   local caption=\$2
   go_fio_1test read      \$disk \"\${caption}: Sequential read\"
   go_fio_1test write     \$disk \"\${caption}: Sequential write\"
   go_fio_1test randread  \$disk \"\${caption}: Random read\"
   go_fio_1test randwrite \$disk \"\${caption}: Random write\"
   if [[ -f \$disk/fiotest.tmp ]]; then rm -f \$disk/fiotest.tmp; fi
 }
 
 go_fio_4tests \"\$DISK\" \"\$CAPTION\"
 exit \$exitCode

" 2>/dev/null >${TARGET_DIR}/File-IO-Benchmark ||
  echo -e "#!/usr/bin/env bash

# Possible \$FILE_IO_BENCHMARK_OPTIONS: --eta=always --time_based

function Has_Unicode() {
  if [[ -n \"\${FORCE_UNICODE:-}\" ]]; then echo \"true\"; return; fi
  if [[ -n \"\${DISABLE_UNICODE:-}\" ]]; then echo \"false\"; return; fi
  if [[ -z \"\${hasUnicode:-}\" ]]; then
    if [[ \"\$(locale charmap 2>/dev/null)\" == \"UTF\"* ]]; then
      hasUnicode=\"true\"
    else
      hasUnicode=\"false\"
    fi
  fi
  echo \$hasUnicode
}

function Header() {
  local char_arrow='>'; local char_dash='-'
  if [[ \"\$(Has_Unicode)\" == \"true\" ]]; then
    char_arrow='\x5CU27A4'; char_dash='\x5CU2500'
  fi
  local txt=\$1
  local length=\${#txt}
  local border=\"\${char_dash}\${char_dash}\${char_dash}\"; while [[ \$length -gt 0 ]]; do border=\"\${char_dash}\${border}\"; length=\$((length-1)); done
  # if [[ \"\${NEXT_HEADER:-}\" == \"\" ]]; then NEXT_HEADER=true; else echo \"\"; fi
  tput bold 2>/dev/null || true
  echo -e \"\${char_arrow} \${txt}\"; echo -e \$border
  tput sgr0 2>/dev/null || true
}

if [[ \"\$1\" == \"\" || \"\$1\" == \"--help\" ]]; then
echo \"Usage: File-IO-Benchmark 'Root FS' / 1G 30 5
here 1G - working set size
     30 - test duration, in seconds
     5  - ramp duration (for VM, raids and ssd 30 seconds is recommended)
Possible \x5C\$FILE_IO_BENCHMARK_OPTIONS: --eta=always --time_based
\"
exit 0;
fi

CAPTION=\$1
DISK=\$2
SIZE=\$3
DURATION=\$4
RAMP=\$5

CAPTION=\${CAPTION:-Current Folder}
DISK=\${DISK:-\$(pwd)}
SIZE=\${SIZE:-1G}
DURATION=\${DURATION:-30}
RAMP=\${RAMP:-5}

export SYSTEM_VERSION_COMPAT=\${SYSTEM_VERSION_COMPAT:-1}
OS_X_VER=\$(sw_vers 2>/dev/null | grep BuildVer | awk '{print \$2}' | cut -c1-2 || true); OS_X_VER=\$((OS_X_VER-4)); [ \"\$OS_X_VER\" -gt 0 ] || unset OS_X_VER

# DETECT io engine
if [[ -n \"\$OS_X_VER\" ]] && [[ \"\$OS_X_VER\" -gt 0 ]]; then ioengine=posixaio; else ioengine=libaio; fi
if [[ \"\$(uname -r)\" == *\"Microsoft\" ]] || [[ \"\$(uname -s)\" == \"MINGW\"* ]]; then ioengine=windowsaio; fi
if [[ -n \"\$FILE_IO_BENCHMARK_ENGINE\" ]]; then ioengine=\$FILE_IO_BENCHMARK_ENGINE; fi

# install fio
 if [[ \"\$(command -v fio 2>/dev/null)\" == \"\" ]]; then
   if [[ \"\$(command -v apt-get 2>/dev/null)\" != \"\" ]]; then
     echo \"Installing fio using apt-get\"
     sudo apt-get install -yqq fio >/tmp/fio-install.log 2>&1 || sudo apt-get install -yqq fio >/tmp/fio-install.log 2>&1 || sudo cat /tmp/fio-install.log
   elif [[ \"\$(command -v yum 2>/dev/null)\" != \"\" ]]; then
     echo \"Installing fio and toilet using yum\"
     sudo yum install -y fio >/tmp/fio-install.log 2>&1 || sudo yum install -y fio >/tmp/fio-install.log 2>&1 || sudo cat /tmp/fio-install.log
   fi
 fi

# check libaio support
pushd \"\$DISK\" >/dev/null
if [[ \"\$ioengine\" == libaio ]]; then
if fio --name=CHECK_LIBAIO --ioengine=\$ioengine --gtod_reduce=1 --filename=fiotest.tmp --bs=4k --size=64k --runtime=1 --readwrite=randread >/dev/null 2>&1; then
  ioengine=libaio
else
  ioengine=posixaio
fi
fi

# check DIRECT IO
direct=0; direct_info=\"Direct IO: [Absent]\"
if fio --name=CHECK_DIRECT_IO --ioengine=\$ioengine --direct=1 --gtod_reduce=1 --filename=fiotest.tmp --bs=4k --size=64k --runtime=1 --readwrite=randread >/dev/null 2>&1; then
  direct=1; direct_info=\"Direct IO: [Present]\"
fi
if [[ -f fiotest.tmp ]]; then rm -f fiotest.tmp; fi
popd >/dev/null

info=\"Detected IO Engine: [\${ioengine}]. \$direct_info\"
echo \"\$info\" # Header \"\$info\"

errorCode=1; exitCode=0;

 function go_fio_1test() {
   local cmd=\$1
   local disk=\$2
   local caption=\"\$3\"
   pushd \"\$disk\" >/dev/null
   Header \"\$caption (\$(pwd))\"
   echo \"Benchmark '\$(pwd)' folder using '\$cmd' test during \$DURATION seconds and heating \$RAMP secs, size is \$SIZE\"
   if [[ \$cmd == \"rand\"* ]]; then
      fio_shell_cmd=\"fio \$FILE_IO_BENCHMARK_OPTIONS --name=RUN_\$cmd --randrepeat=1 --ioengine=\$ioengine --direct=\$direct --gtod_reduce=1 --filename=fiotest.tmp --bs=4k --iodepth=64 --size=\$SIZE --runtime=\$DURATION --ramp_time=\$RAMP --readwrite=\$cmd\"
   else
      fio_shell_cmd=\"fio \$FILE_IO_BENCHMARK_OPTIONS --name=RUN_\$cmd --ioengine=\$ioengine --direct=\$direct --gtod_reduce=1 --filename=fiotest.tmp --bs=1024k --size=\$SIZE --runtime=\$DURATION --ramp_time=\$RAMP --readwrite=\$cmd\"
   fi
   if [[ -n \"\$FILE_IO_BENCHMARK_DUMP_FOLDER\" ]]; then
     fio_version=\"\$(fio --version)\"
     fio_version=\"\${fio_version:-unknown}\"
     mkdir -p \"\$FILE_IO_BENCHMARK_DUMP_FOLDER/\$fio_version\"
     fio_shell_cmd=\"\$fio_shell_cmd | tee \x5C\"\$FILE_IO_BENCHMARK_DUMP_FOLDER/\$fio_version/\$cmd.log\x5C\"\"
   fi
   set -o pipefail
   eval \$fio_shell_cmd
   if [[ \$? == 0 ]]; then isError=0; else isError=1; fi
   exitCode=\$((isError*errorCode + exitCode)); errorCode=\$((errorCode*2))
   popd >/dev/null
   echo \"\"
 }
 
 function go_fio_4tests() {
   local disk=\$1
   local caption=\$2
   go_fio_1test read      \$disk \"\${caption}: Sequential read\"
   go_fio_1test write     \$disk \"\${caption}: Sequential write\"
   go_fio_1test randread  \$disk \"\${caption}: Random read\"
   go_fio_1test randwrite \$disk \"\${caption}: Random write\"
   if [[ -f \$disk/fiotest.tmp ]]; then rm -f \$disk/fiotest.tmp; fi
 }
 
 go_fio_4tests \"\$DISK\" \"\$CAPTION\"
 exit \$exitCode

" | sudo tee ${TARGET_DIR}/File-IO-Benchmark >/dev/null;
  if [[ -f ${TARGET_DIR}/File-IO-Benchmark ]]; then 
      chmod +x ${TARGET_DIR}/File-IO-Benchmark >/dev/null 2>&1 || sudo chmod +x ${TARGET_DIR}/File-IO-Benchmark
  	echo "OK: ${TARGET_DIR}/File-IO-Benchmark"; 
  else "Error: Unable to extract ${TARGET_DIR}/File-IO-Benchmark"; fi
else 
  echo "Skipping ${TARGET_DIR}/File-IO-Benchmark: directory does not exists"
fi


# Get-Git-Tags
if [[ -d ${TARGET_DIR} ]]; then
  echo -e "#!/usr/bin/env bash

# git ls-remote --tags https://github.com/git/git | awk '{n=\$2; gsub(/^refs\x5C/tags\x5C//,\"\", n); if (n ~ /^v?[0-9.]*\$/) { print n } }' | sort -V

# ^{}: https://stackoverflow.com/questions/15472107/when-listing-git-ls-remote-why-theres-after-the-tag-name/15472310
# remove ^{}
# Get-Git-Tags https://github.com/PowerShell/PowerShell --pre | awk '{ n=\$1; if (! (n ~ /\x5C^\x5C{\x5C}\$/) ) { print \$n } }'

# output tags ordered as versions
function get_git_tags() {
  local repo=\"\$1\"; repo=\"\${repo:-https://github.com/nodejs/node}\"
  local need_pre_release=\"\$2\"; 
  if [[ \"\$need_pre_release\" == \"pre\"* || \"\$need_pre_release\" == \"--pre\"* ]]; then 
    need_pre_release=true; else need_pre_release=false; 
  fi
  
  cmd='git ls-remote --tags '\$repo' | awk '\"'\"'{n=\$2; gsub(/^refs\x5C/tags\x5C//,\"\", n);'
  if [[ \$need_pre_release == false ]]; then
    GIT_RELEASE_TAG_FILTER=\${GIT_RELEASE_TAG_FILTER:-/^v?[0-9.]*\$/}
    cmd=\"\$cmd if (n ~ \$GIT_RELEASE_TAG_FILTER && ! ( n ~ /\x5C^\x5C{\x5C}\$/ ))\"
  else 
    cmd=\"\$cmd if (! ( n ~ /\x5C^\x5C{\x5C}\$/ ))\"
  fi
  cmd=\"\$cmd { print n } }' | sort -V\"
  eval \"\$cmd\"
}

if [[ \"\$1\" == \"\" ]]; then
    echo \"Usage Get-Git-Tags https://github.com/nodejs/node [--pre-release|--pre]\"
    echo \"Default filter for tags is /^v?[0-9.]*\$/ It can be overriden by GIT_RELEASE_TAG_FILTER var\"
    exit 0; 
fi

get_git_tags \$1 \$2

" 2>/dev/null >${TARGET_DIR}/Get-Git-Tags ||
  echo -e "#!/usr/bin/env bash

# git ls-remote --tags https://github.com/git/git | awk '{n=\$2; gsub(/^refs\x5C/tags\x5C//,\"\", n); if (n ~ /^v?[0-9.]*\$/) { print n } }' | sort -V

# ^{}: https://stackoverflow.com/questions/15472107/when-listing-git-ls-remote-why-theres-after-the-tag-name/15472310
# remove ^{}
# Get-Git-Tags https://github.com/PowerShell/PowerShell --pre | awk '{ n=\$1; if (! (n ~ /\x5C^\x5C{\x5C}\$/) ) { print \$n } }'

# output tags ordered as versions
function get_git_tags() {
  local repo=\"\$1\"; repo=\"\${repo:-https://github.com/nodejs/node}\"
  local need_pre_release=\"\$2\"; 
  if [[ \"\$need_pre_release\" == \"pre\"* || \"\$need_pre_release\" == \"--pre\"* ]]; then 
    need_pre_release=true; else need_pre_release=false; 
  fi
  
  cmd='git ls-remote --tags '\$repo' | awk '\"'\"'{n=\$2; gsub(/^refs\x5C/tags\x5C//,\"\", n);'
  if [[ \$need_pre_release == false ]]; then
    GIT_RELEASE_TAG_FILTER=\${GIT_RELEASE_TAG_FILTER:-/^v?[0-9.]*\$/}
    cmd=\"\$cmd if (n ~ \$GIT_RELEASE_TAG_FILTER && ! ( n ~ /\x5C^\x5C{\x5C}\$/ ))\"
  else 
    cmd=\"\$cmd if (! ( n ~ /\x5C^\x5C{\x5C}\$/ ))\"
  fi
  cmd=\"\$cmd { print n } }' | sort -V\"
  eval \"\$cmd\"
}

if [[ \"\$1\" == \"\" ]]; then
    echo \"Usage Get-Git-Tags https://github.com/nodejs/node [--pre-release|--pre]\"
    echo \"Default filter for tags is /^v?[0-9.]*\$/ It can be overriden by GIT_RELEASE_TAG_FILTER var\"
    exit 0; 
fi

get_git_tags \$1 \$2

" | sudo tee ${TARGET_DIR}/Get-Git-Tags >/dev/null;
  if [[ -f ${TARGET_DIR}/Get-Git-Tags ]]; then 
      chmod +x ${TARGET_DIR}/Get-Git-Tags >/dev/null 2>&1 || sudo chmod +x ${TARGET_DIR}/Get-Git-Tags
  	echo "OK: ${TARGET_DIR}/Get-Git-Tags"; 
  else "Error: Unable to extract ${TARGET_DIR}/Get-Git-Tags"; fi
else 
  echo "Skipping ${TARGET_DIR}/Get-Git-Tags: directory does not exists"
fi


# Get-GitHub-Latest-Release
if [[ -d ${TARGET_DIR} ]]; then
  echo -e "#!/usr/bin/env bash
# https://developer.github.com/v3/repos/releases/

# output the TAG of the latest release of null 
function get_github_latest_release() {
    local owner=\"\$1\";
    local repo=\"\$2\";
    local query=\"https://api.github.com/repos/\$owner/\$repo/releases/latest\"
    local json=\$(wget -q -nv --no-check-certificate -O - \$query 2>/dev/null || curl -ksSL \$query)
    local tag=\$(echo \"\$json\" | jq -r \".tag_name\" )
    if [[ -n \"\${tag:-}\" && \"\$tag\" != \"null\" ]]; then 
        echo \"\${tag:-}\" 
    fi;
}

if [[ \"\$1\" == \"\" ]]; then
    echo \"Usage Get-GitHub-Latest-Release microsoft azure-pipelines-agent\"
    exit 0; 
fi

owner=\"\$1\"; owner=\${owner:-microsoft}
repo=\"\$2\"; repo=\${repo:-azure-pipelines-agent}

get_github_latest_release \"\${owner:-}\" \"\${repo:-}\"

" 2>/dev/null >${TARGET_DIR}/Get-GitHub-Latest-Release ||
  echo -e "#!/usr/bin/env bash
# https://developer.github.com/v3/repos/releases/

# output the TAG of the latest release of null 
function get_github_latest_release() {
    local owner=\"\$1\";
    local repo=\"\$2\";
    local query=\"https://api.github.com/repos/\$owner/\$repo/releases/latest\"
    local json=\$(wget -q -nv --no-check-certificate -O - \$query 2>/dev/null || curl -ksSL \$query)
    local tag=\$(echo \"\$json\" | jq -r \".tag_name\" )
    if [[ -n \"\${tag:-}\" && \"\$tag\" != \"null\" ]]; then 
        echo \"\${tag:-}\" 
    fi;
}

if [[ \"\$1\" == \"\" ]]; then
    echo \"Usage Get-GitHub-Latest-Release microsoft azure-pipelines-agent\"
    exit 0; 
fi

owner=\"\$1\"; owner=\${owner:-microsoft}
repo=\"\$2\"; repo=\${repo:-azure-pipelines-agent}

get_github_latest_release \"\${owner:-}\" \"\${repo:-}\"

" | sudo tee ${TARGET_DIR}/Get-GitHub-Latest-Release >/dev/null;
  if [[ -f ${TARGET_DIR}/Get-GitHub-Latest-Release ]]; then 
      chmod +x ${TARGET_DIR}/Get-GitHub-Latest-Release >/dev/null 2>&1 || sudo chmod +x ${TARGET_DIR}/Get-GitHub-Latest-Release
  	echo "OK: ${TARGET_DIR}/Get-GitHub-Latest-Release"; 
  else "Error: Unable to extract ${TARGET_DIR}/Get-GitHub-Latest-Release"; fi
else 
  echo "Skipping ${TARGET_DIR}/Get-GitHub-Latest-Release: directory does not exists"
fi


# Get-GitHub-Releases
if [[ -d ${TARGET_DIR} ]]; then
  echo -e "#!/usr/bin/env bash
# https://developer.github.com/v3/repos/releases/#list-releases

function get_github_releases() {
    local owner=\"\$1\";
    local repo=\"\$2\";
    local need_pre_release=\"\$3\"; 
    if [[ \"\$need_pre_release\" == \"pre\"* || \"\$need_pre_release\" == \"--pre\"* ]]; then 
        need_pre_release=true; else need_pre_release=false; 
    fi
    
    local query=\"https://api.github.com/repos/\$owner/\$repo/releases\"
    local jqFilter;
    if [[ \$need_pre_release == \"true\" ]]; then 
        jqFilter=\"\";
    else
        jqFilter='map(select(.prerelease == false))' # array
    fi;
    local jsonFull=\$(wget -q -nv --no-check-certificate -O - \$query 2>/dev/null || curl -ksSL \$query)
    local json=\$(echo \$jsonFull | jq \"\$jqFilter\")
    # jq \".[] | select(.prerelease == false)\"
    echo \$json
}

if [[ \"\$1\" == \"\" ]]; then
    echo \"Usage: Get-GitHub-Releases PowerShell PowerShell [--pre-release]\"
    exit 0; 
fi

owner=\"\$1\"; owner=\${owner:-PowerShell}
repo=\"\$2\"; repo=\${repo:-PowerShell}
need_pre_release=\"\$3\"

get_github_releases \"\${owner:-}\" \"\${repo:-}\" \"\${need_pre_release:-}\"

" 2>/dev/null >${TARGET_DIR}/Get-GitHub-Releases ||
  echo -e "#!/usr/bin/env bash
# https://developer.github.com/v3/repos/releases/#list-releases

function get_github_releases() {
    local owner=\"\$1\";
    local repo=\"\$2\";
    local need_pre_release=\"\$3\"; 
    if [[ \"\$need_pre_release\" == \"pre\"* || \"\$need_pre_release\" == \"--pre\"* ]]; then 
        need_pre_release=true; else need_pre_release=false; 
    fi
    
    local query=\"https://api.github.com/repos/\$owner/\$repo/releases\"
    local jqFilter;
    if [[ \$need_pre_release == \"true\" ]]; then 
        jqFilter=\"\";
    else
        jqFilter='map(select(.prerelease == false))' # array
    fi;
    local jsonFull=\$(wget -q -nv --no-check-certificate -O - \$query 2>/dev/null || curl -ksSL \$query)
    local json=\$(echo \$jsonFull | jq \"\$jqFilter\")
    # jq \".[] | select(.prerelease == false)\"
    echo \$json
}

if [[ \"\$1\" == \"\" ]]; then
    echo \"Usage: Get-GitHub-Releases PowerShell PowerShell [--pre-release]\"
    exit 0; 
fi

owner=\"\$1\"; owner=\${owner:-PowerShell}
repo=\"\$2\"; repo=\${repo:-PowerShell}
need_pre_release=\"\$3\"

get_github_releases \"\${owner:-}\" \"\${repo:-}\" \"\${need_pre_release:-}\"

" | sudo tee ${TARGET_DIR}/Get-GitHub-Releases >/dev/null;
  if [[ -f ${TARGET_DIR}/Get-GitHub-Releases ]]; then 
      chmod +x ${TARGET_DIR}/Get-GitHub-Releases >/dev/null 2>&1 || sudo chmod +x ${TARGET_DIR}/Get-GitHub-Releases
  	echo "OK: ${TARGET_DIR}/Get-GitHub-Releases"; 
  else "Error: Unable to extract ${TARGET_DIR}/Get-GitHub-Releases"; fi
else 
  echo "Skipping ${TARGET_DIR}/Get-GitHub-Releases: directory does not exists"
fi


# Get-Local-Docker-Ip
if [[ -d ${TARGET_DIR} ]]; then
  echo -e "#!/usr/bin/env bash
# if Is-Docker-Container; then
if [[ \"\$(Is-Docker-Container -v)\" == true ]]; then
    ip r | grep -E '^default via ' | awk '{print \$3}'
else
    echo \"127.0.0.1\"
fi

" 2>/dev/null >${TARGET_DIR}/Get-Local-Docker-Ip ||
  echo -e "#!/usr/bin/env bash
# if Is-Docker-Container; then
if [[ \"\$(Is-Docker-Container -v)\" == true ]]; then
    ip r | grep -E '^default via ' | awk '{print \$3}'
else
    echo \"127.0.0.1\"
fi

" | sudo tee ${TARGET_DIR}/Get-Local-Docker-Ip >/dev/null;
  if [[ -f ${TARGET_DIR}/Get-Local-Docker-Ip ]]; then 
      chmod +x ${TARGET_DIR}/Get-Local-Docker-Ip >/dev/null 2>&1 || sudo chmod +x ${TARGET_DIR}/Get-Local-Docker-Ip
  	echo "OK: ${TARGET_DIR}/Get-Local-Docker-Ip"; 
  else "Error: Unable to extract ${TARGET_DIR}/Get-Local-Docker-Ip"; fi
else 
  echo "Skipping ${TARGET_DIR}/Get-Local-Docker-Ip: directory does not exists"
fi


# Is-Docker-Container
if [[ -d ${TARGET_DIR} ]]; then
  echo -e "#!/usr/bin/env bash

if [[ \"\${container:-}\" == \"docker\" || \"\$(grep 'docker' /proc/1/cgroup 2>/dev/null || true)\" != \"\" ]]; then
  if [[ \"\$1\" == \"-v\" ]]; then echo \"true\"; fi
  exit 0;
else
  if [[ \"\$1\" == \"-v\" ]]; then echo \"false\"; fi
  exit 1;
fi

" 2>/dev/null >${TARGET_DIR}/Is-Docker-Container ||
  echo -e "#!/usr/bin/env bash

if [[ \"\${container:-}\" == \"docker\" || \"\$(grep 'docker' /proc/1/cgroup 2>/dev/null || true)\" != \"\" ]]; then
  if [[ \"\$1\" == \"-v\" ]]; then echo \"true\"; fi
  exit 0;
else
  if [[ \"\$1\" == \"-v\" ]]; then echo \"false\"; fi
  exit 1;
fi

" | sudo tee ${TARGET_DIR}/Is-Docker-Container >/dev/null;
  if [[ -f ${TARGET_DIR}/Is-Docker-Container ]]; then 
      chmod +x ${TARGET_DIR}/Is-Docker-Container >/dev/null 2>&1 || sudo chmod +x ${TARGET_DIR}/Is-Docker-Container
  	echo "OK: ${TARGET_DIR}/Is-Docker-Container"; 
  else "Error: Unable to extract ${TARGET_DIR}/Is-Docker-Container"; fi
else 
  echo "Skipping ${TARGET_DIR}/Is-Docker-Container: directory does not exists"
fi


# Is-Fedora
if [[ -d ${TARGET_DIR} ]]; then
  echo -e "#!/usr/bin/env bash
# Usage 1: if [[ \"\$(Is-RedHat 6)\" ]]; then ... 
# Usage 2: if [[ \"\$(Is-RedHat 8)\" ]]; then ... 
# Usage 3: if [[ \"\$(Is-RedHat)\" ]]; then ...
 
if [ -e /etc/os-release ]; then
  . /etc/os-release
  if [[ \"\${ID:-}\" == \"fedora\"* ]]; then
  \x09ret=\"\${VERSION_ID:-}\"
  fi
fi

arg=\"\$1\"
if [ \"\$arg\" = \"\" ]; then
    echo \"\$ret\"
    exit 0
elif [ \"\$arg\" = \"\$ret\" ]; then
    echo \"\$ret\"
    exit 0
else
    exit 1
fi

" 2>/dev/null >${TARGET_DIR}/Is-Fedora ||
  echo -e "#!/usr/bin/env bash
# Usage 1: if [[ \"\$(Is-RedHat 6)\" ]]; then ... 
# Usage 2: if [[ \"\$(Is-RedHat 8)\" ]]; then ... 
# Usage 3: if [[ \"\$(Is-RedHat)\" ]]; then ...
 
if [ -e /etc/os-release ]; then
  . /etc/os-release
  if [[ \"\${ID:-}\" == \"fedora\"* ]]; then
  \x09ret=\"\${VERSION_ID:-}\"
  fi
fi

arg=\"\$1\"
if [ \"\$arg\" = \"\" ]; then
    echo \"\$ret\"
    exit 0
elif [ \"\$arg\" = \"\$ret\" ]; then
    echo \"\$ret\"
    exit 0
else
    exit 1
fi

" | sudo tee ${TARGET_DIR}/Is-Fedora >/dev/null;
  if [[ -f ${TARGET_DIR}/Is-Fedora ]]; then 
      chmod +x ${TARGET_DIR}/Is-Fedora >/dev/null 2>&1 || sudo chmod +x ${TARGET_DIR}/Is-Fedora
  	echo "OK: ${TARGET_DIR}/Is-Fedora"; 
  else "Error: Unable to extract ${TARGET_DIR}/Is-Fedora"; fi
else 
  echo "Skipping ${TARGET_DIR}/Is-Fedora: directory does not exists"
fi


# Is-RedHat
if [[ -d ${TARGET_DIR} ]]; then
  echo -e "#!/usr/bin/env bash
# Usage 1: if [[ \"\$(Is-RedHat 6)\" ]]; then ... 
# Usage 2: if [[ \"\$(Is-RedHat 8)\" ]]; then ... 
# Usage 3: if [[ \"\$(Is-RedHat)\" ]]; then ...
 
if [ -e /etc/redhat-release ]; then
  redhatRelease=\$(</etc/redhat-release)
  case \$redhatRelease in 
    \"CentOS release 6.\"*)                           ret=6 ;;
    \"Red Hat Enterprise Linux Server release 6.\"*)  ret=6 ;;
  esac
fi

if [ -e /etc/os-release ]; then
  . /etc/os-release
  if [ \"\${ID:-}\" = \"rhel\" ] || [ \"\${ID:-}\" = \"centos\" ]; then
    case \"\${VERSION_ID:-}\" in
        \"7\"*)   ret=7 ;;
        \"8\"*)   ret=8 ;;
        \"9\"*)   ret=9 ;;
    esac
  fi
fi

arg=\"\$1\"
if [ \"\$arg\" = \"\" ]; then
    echo \"\$ret\"
    exit 0
elif [ \"\$arg\" = \"\$ret\" ]; then
    echo \"\$ret\"
    exit 0
else
    exit 1
fi

" 2>/dev/null >${TARGET_DIR}/Is-RedHat ||
  echo -e "#!/usr/bin/env bash
# Usage 1: if [[ \"\$(Is-RedHat 6)\" ]]; then ... 
# Usage 2: if [[ \"\$(Is-RedHat 8)\" ]]; then ... 
# Usage 3: if [[ \"\$(Is-RedHat)\" ]]; then ...
 
if [ -e /etc/redhat-release ]; then
  redhatRelease=\$(</etc/redhat-release)
  case \$redhatRelease in 
    \"CentOS release 6.\"*)                           ret=6 ;;
    \"Red Hat Enterprise Linux Server release 6.\"*)  ret=6 ;;
  esac
fi

if [ -e /etc/os-release ]; then
  . /etc/os-release
  if [ \"\${ID:-}\" = \"rhel\" ] || [ \"\${ID:-}\" = \"centos\" ]; then
    case \"\${VERSION_ID:-}\" in
        \"7\"*)   ret=7 ;;
        \"8\"*)   ret=8 ;;
        \"9\"*)   ret=9 ;;
    esac
  fi
fi

arg=\"\$1\"
if [ \"\$arg\" = \"\" ]; then
    echo \"\$ret\"
    exit 0
elif [ \"\$arg\" = \"\$ret\" ]; then
    echo \"\$ret\"
    exit 0
else
    exit 1
fi

" | sudo tee ${TARGET_DIR}/Is-RedHat >/dev/null;
  if [[ -f ${TARGET_DIR}/Is-RedHat ]]; then 
      chmod +x ${TARGET_DIR}/Is-RedHat >/dev/null 2>&1 || sudo chmod +x ${TARGET_DIR}/Is-RedHat
  	echo "OK: ${TARGET_DIR}/Is-RedHat"; 
  else "Error: Unable to extract ${TARGET_DIR}/Is-RedHat"; fi
else 
  echo "Skipping ${TARGET_DIR}/Is-RedHat: directory does not exists"
fi


# lazy-apt-update
if [[ -d ${TARGET_DIR} ]]; then
  echo -e "#!/usr/bin/env bash
# SMART lazy-apt-update - only for built-in Debian repos
# try-and-retry is NOT for here
ls -1 /var/lib/apt/lists/deb* >/dev/null 2>&1 || ls -1 /var/lib/apt/lists/lock >/dev/null 2>&1 || {
    Say \"Updating apt metadata (/var/lib/apt/lists/)\"
    sudo apt-get update --allow-unauthenticated -qq
}


" 2>/dev/null >${TARGET_DIR}/lazy-apt-update ||
  echo -e "#!/usr/bin/env bash
# SMART lazy-apt-update - only for built-in Debian repos
# try-and-retry is NOT for here
ls -1 /var/lib/apt/lists/deb* >/dev/null 2>&1 || ls -1 /var/lib/apt/lists/lock >/dev/null 2>&1 || {
    Say \"Updating apt metadata (/var/lib/apt/lists/)\"
    sudo apt-get update --allow-unauthenticated -qq
}


" | sudo tee ${TARGET_DIR}/lazy-apt-update >/dev/null;
  if [[ -f ${TARGET_DIR}/lazy-apt-update ]]; then 
      chmod +x ${TARGET_DIR}/lazy-apt-update >/dev/null 2>&1 || sudo chmod +x ${TARGET_DIR}/lazy-apt-update
  	echo "OK: ${TARGET_DIR}/lazy-apt-update"; 
  else "Error: Unable to extract ${TARGET_DIR}/lazy-apt-update"; fi
else 
  echo "Skipping ${TARGET_DIR}/lazy-apt-update: directory does not exists"
fi


# list-packages
if [[ -d ${TARGET_DIR} ]]; then
  echo -e "#!/usr/bin/env bash
packages=\$(dpkg --get-selections | grep -v deinstall | awk \"{print \$1}\")
apt-cache --no-all-versions show \$packages |
  awk '
      \$1 == \"Package:\" { p = \$2; v=\"\" }
      \$1 == \"Version:\" { v = \$2 }
      \$1 == \"Size:\"    { printf(\"%10d %s %s\x5Cn\", \$2, p, v) }
  ' | sort -k1 -n

" 2>/dev/null >${TARGET_DIR}/list-packages ||
  echo -e "#!/usr/bin/env bash
packages=\$(dpkg --get-selections | grep -v deinstall | awk \"{print \$1}\")
apt-cache --no-all-versions show \$packages |
  awk '
      \$1 == \"Package:\" { p = \$2; v=\"\" }
      \$1 == \"Version:\" { v = \$2 }
      \$1 == \"Size:\"    { printf(\"%10d %s %s\x5Cn\", \$2, p, v) }
  ' | sort -k1 -n

" | sudo tee ${TARGET_DIR}/list-packages >/dev/null;
  if [[ -f ${TARGET_DIR}/list-packages ]]; then 
      chmod +x ${TARGET_DIR}/list-packages >/dev/null 2>&1 || sudo chmod +x ${TARGET_DIR}/list-packages
  	echo "OK: ${TARGET_DIR}/list-packages"; 
  else "Error: Unable to extract ${TARGET_DIR}/list-packages"; fi
else 
  echo "Skipping ${TARGET_DIR}/list-packages: directory does not exists"
fi


# MySQL-Container
if [[ -d ${TARGET_DIR} ]]; then
  echo -e "#!/usr/bin/env bash
set -e
set -u
MYSQL_CONTAINER_PORT=\${MYSQL_CONTAINER_PORT:-3306}
MYSQL_ROOT_PASSWORD=\"\${MYSQL_ROOT_PASSWORD:-pass}\"
MYSQL_DATABASE=\"\${MYSQL_DATABASE:-app}\"
MYSQL_USER=\"\${MYSQL_USER:-user}\"
MYSQL_PASSWORD=\"\${MYSQL_PASSWORD:-pass}\"
MYSQL_VERSION=\"\${MYSQL_VERSION:-5.7}\"
MYSQL_CONTAINER_NAME=\"\${MYSQL_CONTAINER_NAME:-mysql-\$MYSQL_VERSION-for-integration-tests}\"
WAIT_TIMEOUT=\"\${WAIT_TIMEOUT:-42}\"

 # MySQL-Container start wait-for exec \"SHOW VARIABLES LIKE 'version';\" 
 
 # raw example for default parameter
 # time MYSQL_PWD=pass mysql --protocol=TCP -h localhost -u root -P 3306 -B -N -e \"SHOW VARIABLES LIKE 'version';\" | cat
 
 
# arm|arm64|amd64
function get_docker_arch() {
    local dockerArch=\$(sudo docker version --format '{{.Server.Arch}}') 
    echo \"\${dockerArch:-unknown}\"
}

function is_container_exists() {
    local name=\$1
    local exists=\"true\"; 
    sudo docker logs \"\$name\" >/dev/null 2>&1 || exists=false
    echo \"\$exists\"
}

function is_container_running() {
    local name=\$1
    local isRunning=\"false\"
    # TODO: filter by names only
    if [[ -n \"\$(docker ps | grep \$name || true)\" ]]; then
        isRunning=true
    fi
    echo \$isRunning
}

function stop_container() {
    local name=\$1
    if [[ \"\$(is_container_running \${name})\" != true ]]; then
        Say \"Container \$name is not running\"
    elif [[ \"\$(is_container_exists \${name})\" == true ]]; then
        Say \"Container \$name is absent\"
    else
        Say \"Stopping container \$name\"
        sudo docker stop \"\$name\"
    fi
}

function delete_container() {
    local name=\$1
    if [[ \"\$(is_container_exists \${name})\" == true ]]; then
        Say \"Deleting existing container \$name\"
        sudo docker rm -f \"\$name\"
    else
        Say \"Skip deleting container \$name. It does not exists\"
    fi
}

function delete_image() {
    local image=\$1
    Say \"Deleting the \$image image\" 
    docker rmi -f \"\$image\"
}

# MySQL Specific Functions
function get_mysql_image_name() {
    local image arch=\"\$(get_docker_arch)\"
    if [[ \"\$arch\" == arm ]]; then
        # https://github.com/beercan1989/docker-arm-mysql
        image=\"beercan1989/arm-mysql:latest\"
    elif [[ \"\$arch\" == arm64 && \"\$MYSQL_VERSION\" == \"5.7\" ]]; then
        # https://hub.docker.com/r/ebspace/aarch64-mysql/
        image=\"ebspace/aarch64-mysql:latest\"
    elif [[ \"\$arch\" == arm64 && \"\$MYSQL_VERSION\" == \"8.0\" ]]; then
        # https://hub.docker.com/r/ebspace/aarch64-mysql/
        image=\"mysql/mysql-server:\${MYSQL_VERSION}\"
    elif [[ \"\$arch\" == amd64 ]]; then
        image=\"mysql/mysql-server:\${MYSQL_VERSION}\"
    else 
        Say \"ERROR. MySQL Version \${MYSQL_VERSION} is not supported for [\$arch] architecture\"
        exit 1;
    fi
    echo \$image
}

function start_mysql_container() {
    local image=\$(get_mysql_image_name)
    
    if [[ \"\$(is_container_exists \$MYSQL_CONTAINER_NAME)\" != true ]]; then
        # container is absent
        Say \"Pulling the \$image image if required\"
        sudo docker pull \"\$image\"
        
        Say \"Creating \$MYSQL_CONTAINER_NAME container\"
        docker run -d \x5C
          -e \"MYSQL_ROOT_HOST=%\" \x5C
          -e \"MYSQL_ROOT_PASSWORD=\${MYSQL_ROOT_PASSWORD}\" \x5C
          -e \"MYSQL_DATABASE=\${MYSQL_DATABASE}\" \x5C
          -e \"MYSQL_USER=\${MYSQL_USER}\" \x5C
          -e \"MYSQL_PASSWORD=\${MYSQL_PASSWORD}}\" \x5C
          -p \"\${MYSQL_CONTAINER_PORT}:3306\" \x5C
          --name \$MYSQL_CONTAINER_NAME \x5C
          \"\$image\"
    elif [[ \"\$(is_container_running \$MYSQL_CONTAINER_NAME)\" == false ]]; then
        # container exists but stopped
        Say \"Starting existing \$MYSQL_CONTAINER_NAME container\"
        docker start \$MYSQL_CONTAINER_NAME
    else 
        Say \"Container \$MYSQL_CONTAINER_NAME already running\"
    fi
    
    # TODO: wait for connection
}

function exec_statement(){
    local cmd=\$1
    MYSQL_PWD=\"\${MYSQL_PASSWORD}\" mysql --protocol=TCP -h \$(Get-Local-Docker-Ip) -u root -P \${MYSQL_CONTAINER_PORT} -B -N -e \"\$cmd\" | cat
}

function wait_for_mysql() {
    local name=\$1 port=\$2 counter=0 total=\$WAIT_TIMEOUT started=\"\"
    Say \"Waiting for \$name on \$(Get-Local-Docker-Ip):\${port}\"
    while [ \$counter -lt \$total ]; do
        counter=\$((counter+1));
        # mysql --protocol=TCP -h localhost -u root -p\"\${MYSQL_ROOT_PASSWORD}\" -P \$p -e \"Select 1;\" 2>/dev/null 1>&2 && started=\"yes\" || true
        docker exec -t \$name mysql --protocol=TCP -h localhost -u root -p\"\${MYSQL_ROOT_PASSWORD}\" -P 3306 -e \"Select 1;\" 2>/dev/null 1>&2 && started=\"yes\" || true
        if [ -n \"\$started\" ]; then printf \"OK\"; break; else (sleep 1; printf \"\${counter}.\"); fi
    done
    if [ -z \"\$started\" ]; then printf \" Fail\x5Cn\"; else
        ver=\$(docker exec -t \$name sh -c \"MYSQL_PWD=\x5C\"\$MYSQL_ROOT_PASSWORD\x5C\" mysql -s -N --protocol=TCP -h localhost -u root -P 3306 -e 'Select version();' 2>&1\")
        printf \", Ver is \$ver\x5Cn\"
    fi
}

function list_supported_versions() {
    local arch=\"\$(get_docker_arch)\"
    if [[   \"\$arch\" == arm   ]]; then echo \"5.7\"; 
    elif [[ \"\$arch\" == arm64 ]]; then echo \"5.7 8.0\"; 
    elif [[ \"\$arch\" == arm   ]]; then echo \"5.5 5.6 5.7 8.0\";
    else echo \"\"; fi 
}

while [ \$# -ne 0 ]; do
    param=\"\$1\"
    case \"\$param\" in
        start) start_mysql_container ;;
        reset) delete_container \$MYSQL_CONTAINER_NAME; start_mysql_container ;;
        stop) stop_container \$MYSQL_CONTAINER_NAME ;;
        delete) delete_container \$MYSQL_CONTAINER_NAME ;;
        \"delete-image\") delete_image \$(get_mysql_image_name) ;;
        exec) cmd=\"\$2\"; shift; exec_statement \"\$cmd\" ;;
        \"wait-for\") wait_for_mysql \"\$MYSQL_CONTAINER_NAME\" \$MYSQL_CONTAINER_PORT ;;
        \"list-supported-versions\") list_supported_versions ;;  
    esac
    shift
done
# 1:22

" 2>/dev/null >${TARGET_DIR}/MySQL-Container ||
  echo -e "#!/usr/bin/env bash
set -e
set -u
MYSQL_CONTAINER_PORT=\${MYSQL_CONTAINER_PORT:-3306}
MYSQL_ROOT_PASSWORD=\"\${MYSQL_ROOT_PASSWORD:-pass}\"
MYSQL_DATABASE=\"\${MYSQL_DATABASE:-app}\"
MYSQL_USER=\"\${MYSQL_USER:-user}\"
MYSQL_PASSWORD=\"\${MYSQL_PASSWORD:-pass}\"
MYSQL_VERSION=\"\${MYSQL_VERSION:-5.7}\"
MYSQL_CONTAINER_NAME=\"\${MYSQL_CONTAINER_NAME:-mysql-\$MYSQL_VERSION-for-integration-tests}\"
WAIT_TIMEOUT=\"\${WAIT_TIMEOUT:-42}\"

 # MySQL-Container start wait-for exec \"SHOW VARIABLES LIKE 'version';\" 
 
 # raw example for default parameter
 # time MYSQL_PWD=pass mysql --protocol=TCP -h localhost -u root -P 3306 -B -N -e \"SHOW VARIABLES LIKE 'version';\" | cat
 
 
# arm|arm64|amd64
function get_docker_arch() {
    local dockerArch=\$(sudo docker version --format '{{.Server.Arch}}') 
    echo \"\${dockerArch:-unknown}\"
}

function is_container_exists() {
    local name=\$1
    local exists=\"true\"; 
    sudo docker logs \"\$name\" >/dev/null 2>&1 || exists=false
    echo \"\$exists\"
}

function is_container_running() {
    local name=\$1
    local isRunning=\"false\"
    # TODO: filter by names only
    if [[ -n \"\$(docker ps | grep \$name || true)\" ]]; then
        isRunning=true
    fi
    echo \$isRunning
}

function stop_container() {
    local name=\$1
    if [[ \"\$(is_container_running \${name})\" != true ]]; then
        Say \"Container \$name is not running\"
    elif [[ \"\$(is_container_exists \${name})\" == true ]]; then
        Say \"Container \$name is absent\"
    else
        Say \"Stopping container \$name\"
        sudo docker stop \"\$name\"
    fi
}

function delete_container() {
    local name=\$1
    if [[ \"\$(is_container_exists \${name})\" == true ]]; then
        Say \"Deleting existing container \$name\"
        sudo docker rm -f \"\$name\"
    else
        Say \"Skip deleting container \$name. It does not exists\"
    fi
}

function delete_image() {
    local image=\$1
    Say \"Deleting the \$image image\" 
    docker rmi -f \"\$image\"
}

# MySQL Specific Functions
function get_mysql_image_name() {
    local image arch=\"\$(get_docker_arch)\"
    if [[ \"\$arch\" == arm ]]; then
        # https://github.com/beercan1989/docker-arm-mysql
        image=\"beercan1989/arm-mysql:latest\"
    elif [[ \"\$arch\" == arm64 && \"\$MYSQL_VERSION\" == \"5.7\" ]]; then
        # https://hub.docker.com/r/ebspace/aarch64-mysql/
        image=\"ebspace/aarch64-mysql:latest\"
    elif [[ \"\$arch\" == arm64 && \"\$MYSQL_VERSION\" == \"8.0\" ]]; then
        # https://hub.docker.com/r/ebspace/aarch64-mysql/
        image=\"mysql/mysql-server:\${MYSQL_VERSION}\"
    elif [[ \"\$arch\" == amd64 ]]; then
        image=\"mysql/mysql-server:\${MYSQL_VERSION}\"
    else 
        Say \"ERROR. MySQL Version \${MYSQL_VERSION} is not supported for [\$arch] architecture\"
        exit 1;
    fi
    echo \$image
}

function start_mysql_container() {
    local image=\$(get_mysql_image_name)
    
    if [[ \"\$(is_container_exists \$MYSQL_CONTAINER_NAME)\" != true ]]; then
        # container is absent
        Say \"Pulling the \$image image if required\"
        sudo docker pull \"\$image\"
        
        Say \"Creating \$MYSQL_CONTAINER_NAME container\"
        docker run -d \x5C
          -e \"MYSQL_ROOT_HOST=%\" \x5C
          -e \"MYSQL_ROOT_PASSWORD=\${MYSQL_ROOT_PASSWORD}\" \x5C
          -e \"MYSQL_DATABASE=\${MYSQL_DATABASE}\" \x5C
          -e \"MYSQL_USER=\${MYSQL_USER}\" \x5C
          -e \"MYSQL_PASSWORD=\${MYSQL_PASSWORD}}\" \x5C
          -p \"\${MYSQL_CONTAINER_PORT}:3306\" \x5C
          --name \$MYSQL_CONTAINER_NAME \x5C
          \"\$image\"
    elif [[ \"\$(is_container_running \$MYSQL_CONTAINER_NAME)\" == false ]]; then
        # container exists but stopped
        Say \"Starting existing \$MYSQL_CONTAINER_NAME container\"
        docker start \$MYSQL_CONTAINER_NAME
    else 
        Say \"Container \$MYSQL_CONTAINER_NAME already running\"
    fi
    
    # TODO: wait for connection
}

function exec_statement(){
    local cmd=\$1
    MYSQL_PWD=\"\${MYSQL_PASSWORD}\" mysql --protocol=TCP -h \$(Get-Local-Docker-Ip) -u root -P \${MYSQL_CONTAINER_PORT} -B -N -e \"\$cmd\" | cat
}

function wait_for_mysql() {
    local name=\$1 port=\$2 counter=0 total=\$WAIT_TIMEOUT started=\"\"
    Say \"Waiting for \$name on \$(Get-Local-Docker-Ip):\${port}\"
    while [ \$counter -lt \$total ]; do
        counter=\$((counter+1));
        # mysql --protocol=TCP -h localhost -u root -p\"\${MYSQL_ROOT_PASSWORD}\" -P \$p -e \"Select 1;\" 2>/dev/null 1>&2 && started=\"yes\" || true
        docker exec -t \$name mysql --protocol=TCP -h localhost -u root -p\"\${MYSQL_ROOT_PASSWORD}\" -P 3306 -e \"Select 1;\" 2>/dev/null 1>&2 && started=\"yes\" || true
        if [ -n \"\$started\" ]; then printf \"OK\"; break; else (sleep 1; printf \"\${counter}.\"); fi
    done
    if [ -z \"\$started\" ]; then printf \" Fail\x5Cn\"; else
        ver=\$(docker exec -t \$name sh -c \"MYSQL_PWD=\x5C\"\$MYSQL_ROOT_PASSWORD\x5C\" mysql -s -N --protocol=TCP -h localhost -u root -P 3306 -e 'Select version();' 2>&1\")
        printf \", Ver is \$ver\x5Cn\"
    fi
}

function list_supported_versions() {
    local arch=\"\$(get_docker_arch)\"
    if [[   \"\$arch\" == arm   ]]; then echo \"5.7\"; 
    elif [[ \"\$arch\" == arm64 ]]; then echo \"5.7 8.0\"; 
    elif [[ \"\$arch\" == arm   ]]; then echo \"5.5 5.6 5.7 8.0\";
    else echo \"\"; fi 
}

while [ \$# -ne 0 ]; do
    param=\"\$1\"
    case \"\$param\" in
        start) start_mysql_container ;;
        reset) delete_container \$MYSQL_CONTAINER_NAME; start_mysql_container ;;
        stop) stop_container \$MYSQL_CONTAINER_NAME ;;
        delete) delete_container \$MYSQL_CONTAINER_NAME ;;
        \"delete-image\") delete_image \$(get_mysql_image_name) ;;
        exec) cmd=\"\$2\"; shift; exec_statement \"\$cmd\" ;;
        \"wait-for\") wait_for_mysql \"\$MYSQL_CONTAINER_NAME\" \$MYSQL_CONTAINER_PORT ;;
        \"list-supported-versions\") list_supported_versions ;;  
    esac
    shift
done
# 1:22

" | sudo tee ${TARGET_DIR}/MySQL-Container >/dev/null;
  if [[ -f ${TARGET_DIR}/MySQL-Container ]]; then 
      chmod +x ${TARGET_DIR}/MySQL-Container >/dev/null 2>&1 || sudo chmod +x ${TARGET_DIR}/MySQL-Container
  	echo "OK: ${TARGET_DIR}/MySQL-Container"; 
  else "Error: Unable to extract ${TARGET_DIR}/MySQL-Container"; fi
else 
  echo "Skipping ${TARGET_DIR}/MySQL-Container: directory does not exists"
fi


# Reset-Target-Framework
if [[ -d ${TARGET_DIR} ]]; then
  echo -e "#!/usr/bin/env bash

function get_legacy_framework_version() {
  local fw=\"\$1\";
  case \$fw in
    net20)     echo \"v2.0\";;
    net30)     echo \"v3.0\";;
    net35)     echo \"v3.5\";;
    net40)     echo \"v4.0\";;
    net45)     echo \"v4.5\";;
    net451)    echo \"v4.5.1\";;
    net452)    echo \"v4.5.2\";;
    net46)     echo \"v4.6\";;
    net461)    echo \"v4.6.1\";;
    net462)    echo \"v4.6.2\";;
    net47)     echo \"v4.7\";;
    net471)    echo \"v4.7.1\";;
    net472)    echo \"v4.7.2\";;
    net48)     echo \"v4.8\";;
    *)         echo \"latest\";;
  esac
}

TARGET_FRAMEWORK=
LANGUAGE=
REVERT=
DRY_RUN=
HELP=
POSITIONAL_PARAMETERS=()
while [[ \$# -gt 0 ]]; do
    key=\"\$1\"
    case \${key} in
        
        -fw|--framework)
        TARGET_FRAMEWORK=\"\$2\"
        shift; shift;;
        
        -l|--language)
        LANGUAGE=\"\$2\"
        shift; shift;;

        -r|--revert)
        REVERT=true
        shift;;

        --dry-run)
        DRY_RUN=true
        shift;;

        -h|--help)
        HELP=true
        shift;;

        *)    
        POSITIONAL+=(\"\$1\")
        echo \"Reset-Target-Framework: INFO. Unknown argument \$1\"  
        shift;;
    esac
done

if [[ -n \"\$HELP\" ]]; then echo 'Usage:
Reset-Target-Framework \x5C
    [-fw|--framework net40|net45|net451|net452|net46|net461|net452|net47|net471|net472|net48] \x5C
    [-l|--language 1|2|3|..|7.0|7.1|7.2|8.0|latest]
    [--dry-run]

    The list of supported versions: csc /langversion:?
    
or 
Reset-Target-Framework -h|--help
    
or 
Reset-Target-Framework --revert
'
    exit 0;
fi

echo \"Solution/Project tree '\$(pwd)'\"

if [[ -n \"\$DRY_RUN\" ]]; then 
    echo \"Dry run - is a check only mode without any changes in project files\"; 
fi

if [[ -n \"\$REVERT\" ]]; then
    echo \"Reverting project files from backups (didn't try git reset --hard; git clean -fx)\" 
    find . | grep -E \"\x5C.csproj\$\" | while read csproj; do
      # echo \"csproj: \$csproj\"
      if [[ -f \"\${csproj}.backup\" ]]; then 
        echo \"Reverting project File '\${csproj}'\"
        mv -f \"\${csproj}.backup\" \"\${csproj}\"; 
      fi
    done
    exit 0;
fi



if [[ -n \"\$TARGET_FRAMEWORK\" ]]; then
    echo \"Resetting <TargetFramework[s]> to '\$TARGET_FRAMEWORK'\"
    LEGACY_TARGET_FRAMEWORK=\"\$(get_legacy_framework_version \${TARGET_FRAMEWORK})\"
    echo \"Resetting <TargetFrameworkVersion> to '\$LEGACY_TARGET_FRAMEWORK'\"
else
    echo \"Keep <TargetFramework/TargetFrameworks/TargetFrameworkVersion> as is\"
fi

if [[ -n \"\$LANGUAGE\" ]]; then
    echo \"Resetting <LangVersion> to '\$LANGUAGE'\"
else
    echo \"Keep <LangVersion> as is\"
fi

find . | grep -E \"\x5C.csproj\$\" | while read csproj; do
  # echo \"csproj: \$csproj\"
  if [[ ! -f \"\${csproj}.backup\" ]]; then cp \"\${csproj}\" \"\${csproj}.backup\"; fi
  lines=\$(cat \"\${csproj}\" | grep -E \"<TargetFrameworks>\")
  echo \"Project File '\${csproj}':\"
  
  if [[ -n \"\$TARGET_FRAMEWORK\" ]]; then
      # Check for <TargetFrameworks> 
      tfs_prev=\$(cat \"\${csproj}\" | grep -oP \"<TargetFrameworks>(.*)</TargetFrameworks>\"  | cut -d \">\" -f 2 | cut -d \"<\" -f 1)
      if [[ -n \"\$tfs_prev\" ]]; then
        printf \"    TargetFrameworks: '\$tfs_prev' --> '\$TARGET_FRAMEWORK'\x5Cn\"
        sed_cmd='/<TargetFrameworks>/c\x5C<TargetFrameworks>'\$TARGET_FRAMEWORK'<\x5C/TargetFrameworks>'
        # printf \"    sed cmd: [\$sed_cmd]\x5Cn\"
        sed -i \"\$sed_cmd\" \$csproj
      fi
      
      # Check for <TargetFramework>
      tf_prev=\$(cat \"\${csproj}\" | grep -oP \"<TargetFramework>(.*)</TargetFramework>\"  | cut -d \">\" -f 2 | cut -d \"<\" -f 1)
      if [[ -n \"\$tf_prev\" ]]; then
        echo \"    TargetFramework: '\$tf_prev' --> '\$TARGET_FRAMEWORK'\"
        sed_cmd='/<TargetFramework>/c\x5C<TargetFramework>'\$TARGET_FRAMEWORK'<\x5C/TargetFramework>'
        # echo \"    sed cmd: [\$sed_cmd]\"
        sed -i \"\$sed_cmd\" \$csproj
      fi
      
      # Check for <TargetFrameworkVersion>
      tfv_prev=\$(cat \"\${csproj}\" | grep -oP \"<TargetFrameworkVersion>(.*)</TargetFrameworkVersion>\"  | cut -d \">\" -f 2 | cut -d \"<\" -f 1)
      if [[ -n \"\$tfv_prev\" ]]; then
        echo \"    TargetFrameworkVersion: '\$tfv_prev' --> '\$LEGACY_TARGET_FRAMEWORK'\"
        sed_cmd='/<TargetFrameworkVersion>/c\x5C<TargetFrameworkVersion>'\$LEGACY_TARGET_FRAMEWORK'<\x5C/TargetFrameworkVersion>'
        # echo \"    sed cmd: [\$sed_cmd]\"
        sed -i \"\$sed_cmd\" \$csproj
      fi
      
      # Is nothing found?
      if [[ -z \"\$tfs_prev\" && -z \"\$tf_prev\" && -z \"\$tfv_prev\" ]]; then
        echo \"    Warning! Neither <TargetFrameworks> nor <TargetFramework> or <TargetFrameworkVersion> are found, but framework was specified as \$TARGET_FRAMEWORK\"
      fi
  fi
  
    if [[ -n \"\$LANGUAGE\" ]]; then
      # Check for <LangVersion> 
      lang_prev=\$(cat \"\${csproj}\" | grep -oP \"<LangVersion>(.*)</LangVersion>\"  | cut -d \">\" -f 2 | cut -d \"<\" -f 1)
      if [[ -n \"\$lang_prev\" ]]; then
        printf \"    <LangVersion>: '\$lang_prev' --> '\$LANGUAGE'\x5Cn\"
        sed_cmd='/<LangVersion>/c\x5C<LangVersion>'\$LANGUAGE'<\x5C/LangVersion>'
        # printf \"    sed cmd: [\$sed_cmd]\x5Cn\"
        sed -i \"\$sed_cmd\" \$csproj
      else
        echo \"    Warning! <LangVersion> not found, but language was specified as \$LANGUAGE\"
      fi
    fi

  
   

  # echo \$lines
  # echo \"TargetFrameworks: \$fw\"
  echo \"\"
done

" 2>/dev/null >${TARGET_DIR}/Reset-Target-Framework ||
  echo -e "#!/usr/bin/env bash

function get_legacy_framework_version() {
  local fw=\"\$1\";
  case \$fw in
    net20)     echo \"v2.0\";;
    net30)     echo \"v3.0\";;
    net35)     echo \"v3.5\";;
    net40)     echo \"v4.0\";;
    net45)     echo \"v4.5\";;
    net451)    echo \"v4.5.1\";;
    net452)    echo \"v4.5.2\";;
    net46)     echo \"v4.6\";;
    net461)    echo \"v4.6.1\";;
    net462)    echo \"v4.6.2\";;
    net47)     echo \"v4.7\";;
    net471)    echo \"v4.7.1\";;
    net472)    echo \"v4.7.2\";;
    net48)     echo \"v4.8\";;
    *)         echo \"latest\";;
  esac
}

TARGET_FRAMEWORK=
LANGUAGE=
REVERT=
DRY_RUN=
HELP=
POSITIONAL_PARAMETERS=()
while [[ \$# -gt 0 ]]; do
    key=\"\$1\"
    case \${key} in
        
        -fw|--framework)
        TARGET_FRAMEWORK=\"\$2\"
        shift; shift;;
        
        -l|--language)
        LANGUAGE=\"\$2\"
        shift; shift;;

        -r|--revert)
        REVERT=true
        shift;;

        --dry-run)
        DRY_RUN=true
        shift;;

        -h|--help)
        HELP=true
        shift;;

        *)    
        POSITIONAL+=(\"\$1\")
        echo \"Reset-Target-Framework: INFO. Unknown argument \$1\"  
        shift;;
    esac
done

if [[ -n \"\$HELP\" ]]; then echo 'Usage:
Reset-Target-Framework \x5C
    [-fw|--framework net40|net45|net451|net452|net46|net461|net452|net47|net471|net472|net48] \x5C
    [-l|--language 1|2|3|..|7.0|7.1|7.2|8.0|latest]
    [--dry-run]

    The list of supported versions: csc /langversion:?
    
or 
Reset-Target-Framework -h|--help
    
or 
Reset-Target-Framework --revert
'
    exit 0;
fi

echo \"Solution/Project tree '\$(pwd)'\"

if [[ -n \"\$DRY_RUN\" ]]; then 
    echo \"Dry run - is a check only mode without any changes in project files\"; 
fi

if [[ -n \"\$REVERT\" ]]; then
    echo \"Reverting project files from backups (didn't try git reset --hard; git clean -fx)\" 
    find . | grep -E \"\x5C.csproj\$\" | while read csproj; do
      # echo \"csproj: \$csproj\"
      if [[ -f \"\${csproj}.backup\" ]]; then 
        echo \"Reverting project File '\${csproj}'\"
        mv -f \"\${csproj}.backup\" \"\${csproj}\"; 
      fi
    done
    exit 0;
fi



if [[ -n \"\$TARGET_FRAMEWORK\" ]]; then
    echo \"Resetting <TargetFramework[s]> to '\$TARGET_FRAMEWORK'\"
    LEGACY_TARGET_FRAMEWORK=\"\$(get_legacy_framework_version \${TARGET_FRAMEWORK})\"
    echo \"Resetting <TargetFrameworkVersion> to '\$LEGACY_TARGET_FRAMEWORK'\"
else
    echo \"Keep <TargetFramework/TargetFrameworks/TargetFrameworkVersion> as is\"
fi

if [[ -n \"\$LANGUAGE\" ]]; then
    echo \"Resetting <LangVersion> to '\$LANGUAGE'\"
else
    echo \"Keep <LangVersion> as is\"
fi

find . | grep -E \"\x5C.csproj\$\" | while read csproj; do
  # echo \"csproj: \$csproj\"
  if [[ ! -f \"\${csproj}.backup\" ]]; then cp \"\${csproj}\" \"\${csproj}.backup\"; fi
  lines=\$(cat \"\${csproj}\" | grep -E \"<TargetFrameworks>\")
  echo \"Project File '\${csproj}':\"
  
  if [[ -n \"\$TARGET_FRAMEWORK\" ]]; then
      # Check for <TargetFrameworks> 
      tfs_prev=\$(cat \"\${csproj}\" | grep -oP \"<TargetFrameworks>(.*)</TargetFrameworks>\"  | cut -d \">\" -f 2 | cut -d \"<\" -f 1)
      if [[ -n \"\$tfs_prev\" ]]; then
        printf \"    TargetFrameworks: '\$tfs_prev' --> '\$TARGET_FRAMEWORK'\x5Cn\"
        sed_cmd='/<TargetFrameworks>/c\x5C<TargetFrameworks>'\$TARGET_FRAMEWORK'<\x5C/TargetFrameworks>'
        # printf \"    sed cmd: [\$sed_cmd]\x5Cn\"
        sed -i \"\$sed_cmd\" \$csproj
      fi
      
      # Check for <TargetFramework>
      tf_prev=\$(cat \"\${csproj}\" | grep -oP \"<TargetFramework>(.*)</TargetFramework>\"  | cut -d \">\" -f 2 | cut -d \"<\" -f 1)
      if [[ -n \"\$tf_prev\" ]]; then
        echo \"    TargetFramework: '\$tf_prev' --> '\$TARGET_FRAMEWORK'\"
        sed_cmd='/<TargetFramework>/c\x5C<TargetFramework>'\$TARGET_FRAMEWORK'<\x5C/TargetFramework>'
        # echo \"    sed cmd: [\$sed_cmd]\"
        sed -i \"\$sed_cmd\" \$csproj
      fi
      
      # Check for <TargetFrameworkVersion>
      tfv_prev=\$(cat \"\${csproj}\" | grep -oP \"<TargetFrameworkVersion>(.*)</TargetFrameworkVersion>\"  | cut -d \">\" -f 2 | cut -d \"<\" -f 1)
      if [[ -n \"\$tfv_prev\" ]]; then
        echo \"    TargetFrameworkVersion: '\$tfv_prev' --> '\$LEGACY_TARGET_FRAMEWORK'\"
        sed_cmd='/<TargetFrameworkVersion>/c\x5C<TargetFrameworkVersion>'\$LEGACY_TARGET_FRAMEWORK'<\x5C/TargetFrameworkVersion>'
        # echo \"    sed cmd: [\$sed_cmd]\"
        sed -i \"\$sed_cmd\" \$csproj
      fi
      
      # Is nothing found?
      if [[ -z \"\$tfs_prev\" && -z \"\$tf_prev\" && -z \"\$tfv_prev\" ]]; then
        echo \"    Warning! Neither <TargetFrameworks> nor <TargetFramework> or <TargetFrameworkVersion> are found, but framework was specified as \$TARGET_FRAMEWORK\"
      fi
  fi
  
    if [[ -n \"\$LANGUAGE\" ]]; then
      # Check for <LangVersion> 
      lang_prev=\$(cat \"\${csproj}\" | grep -oP \"<LangVersion>(.*)</LangVersion>\"  | cut -d \">\" -f 2 | cut -d \"<\" -f 1)
      if [[ -n \"\$lang_prev\" ]]; then
        printf \"    <LangVersion>: '\$lang_prev' --> '\$LANGUAGE'\x5Cn\"
        sed_cmd='/<LangVersion>/c\x5C<LangVersion>'\$LANGUAGE'<\x5C/LangVersion>'
        # printf \"    sed cmd: [\$sed_cmd]\x5Cn\"
        sed -i \"\$sed_cmd\" \$csproj
      else
        echo \"    Warning! <LangVersion> not found, but language was specified as \$LANGUAGE\"
      fi
    fi

  
   

  # echo \$lines
  # echo \"TargetFrameworks: \$fw\"
  echo \"\"
done

" | sudo tee ${TARGET_DIR}/Reset-Target-Framework >/dev/null;
  if [[ -f ${TARGET_DIR}/Reset-Target-Framework ]]; then 
      chmod +x ${TARGET_DIR}/Reset-Target-Framework >/dev/null 2>&1 || sudo chmod +x ${TARGET_DIR}/Reset-Target-Framework
  	echo "OK: ${TARGET_DIR}/Reset-Target-Framework"; 
  else "Error: Unable to extract ${TARGET_DIR}/Reset-Target-Framework"; fi
else 
  echo "Skipping ${TARGET_DIR}/Reset-Target-Framework: directory does not exists"
fi


# Say
if [[ -d ${TARGET_DIR} ]]; then
  echo -e "#!/usr/bin/env bash

  function get_stopwatch_file_name() {
    user=\"\${LOGNAME:-\$(whoami)}\"
    file1=\"/tmp/.\${user}-stopwatch-for-say\"
    echo \$file1
  }

  function get_counter_file_name() {
    user=\"\${LOGNAME:-\$(whoami)}\"
    file2=\"/tmp/.\${user}-counter-for-say\"
    echo \$file2
  }
  
  function format2digits() {
    if [[ \$1 -gt 9 ]]; then echo \$1; else echo 0\$1; fi
  }

  function get_global_seconds() {
    theSYSTEM=\"\${theSYSTEM:-\$(uname -s)}\"
    if [[ \${theSYSTEM} != \"Darwin\" ]]; then
        uptime=\$(</proc/uptime);                  # 42645.93 240538.58
        IFS=' ' read -ra uptime <<< \"\$uptime\";    # 42645.93 240538.58
        uptime=\"\${uptime[0]}\";                    # 42645.93
        uptime=\$(printf \"%.0f\x5Cn\" \"\$uptime\")       # 42645
        echo \$uptime
    else 
        # https://stackoverflow.com/questions/15329443/proc-uptime-in-mac-os-x
        boottime=\`sysctl -n kern.boottime | awk '{print \$4}' | sed 's/,//g'\`
        unixtime=\`date +%s\`
\x09    timeAgo=\$((\$unixtime - \$boottime))
\x09    echo \$timeAgo
    fi
  }

  function format_total_seconds() {
    timeAgo=\$1
    seconds1=\$((timeAgo % 86400));
    seconds=\$((seconds1 % 60));
    minutes1=\$((seconds1 / 60));
    minutes=\$((minutes1 % 60));
    hours=\$((minutes1 / 60));
    echo \"\$(format2digits \$hours):\$(format2digits \$minutes):\$(format2digits \$seconds)\"
  }

  function print_header() {
    global_seconds=\"\$(get_global_seconds)\"

    # zero is 0?
    stopwatch_file=\"\$(get_stopwatch_file_name)\"
    if [[ -s \"\$stopwatch_file\" ]]; then
      zero_seconds=\$(<\$stopwatch_file)
      global_seconds=\$((global_seconds-zero_seconds))
    fi
    
    uptime=\"\$(format_total_seconds \$global_seconds)\"

    black_circle='\x5CxE2\x5Cx97\x5Cx8f'
    white_circle='\x5CxE2\x5Cx97\x5Cx8b'
    # BUILD_DEFINITIONNAME
    # if [[ -z \"\$BUILD_DEFINITIONNAME\" ]]; then 
    if [[ -z \"\$SAY_COLORLESS\" ]]; then # skip colors for azure pipelines
      Blue='\x5C033[1;34m'; Gray='\x5C033[1;37m'; LightGreen='\x5C033[1;32m'; Yellow='\x5C033[1;33m'; RED='\x5C033[0;31m'; NC='\x5C033[0m'; LightGray='\x5C033[1;2m';
    fi
    hostname=\"\$(hostname 2>/dev/null)\"
    hostname=\"\${hostname:-\$HOSTNAME}\"
    printf \"\${Blue}\${black_circle} \${hostname}\${NC} \${LightGray}[\${uptime:-}]\${NC} \${LightGreen}\$1\${NC} \${Yellow}\"; echo -n \"\$2\"; printf \"\${NC}\x5Cn\";
    echo \"\${hostname} \${uptime:-} \$1 \$2\" >> \"/tmp/Said-by-\$(whoami).log\" 2>/dev/null 
  }

  function SayIt() { 
    counter_file=\"\$(get_counter_file_name)\"
    if [[ -e \"\$counter_file\" ]]; then counter=\$(< \"\$counter_file\"); else counter=1; fi
    print_header \"#\${counter}\" \"\$1\";
    counter=\$((counter+1));
    echo \$counter > \"\$counter_file\"
  }; 


if [[ \"\$1\" == \"--Reset-Stopwatch\" ]]; then
  echo \"\$(get_global_seconds)\" > \"\$(get_stopwatch_file_name)\"
  echo 1 > \"\$(get_counter_file_name)\"
  exit 0;
fi

SayIt \"\$@\"

" 2>/dev/null >${TARGET_DIR}/Say ||
  echo -e "#!/usr/bin/env bash

  function get_stopwatch_file_name() {
    user=\"\${LOGNAME:-\$(whoami)}\"
    file1=\"/tmp/.\${user}-stopwatch-for-say\"
    echo \$file1
  }

  function get_counter_file_name() {
    user=\"\${LOGNAME:-\$(whoami)}\"
    file2=\"/tmp/.\${user}-counter-for-say\"
    echo \$file2
  }
  
  function format2digits() {
    if [[ \$1 -gt 9 ]]; then echo \$1; else echo 0\$1; fi
  }

  function get_global_seconds() {
    theSYSTEM=\"\${theSYSTEM:-\$(uname -s)}\"
    if [[ \${theSYSTEM} != \"Darwin\" ]]; then
        uptime=\$(</proc/uptime);                  # 42645.93 240538.58
        IFS=' ' read -ra uptime <<< \"\$uptime\";    # 42645.93 240538.58
        uptime=\"\${uptime[0]}\";                    # 42645.93
        uptime=\$(printf \"%.0f\x5Cn\" \"\$uptime\")       # 42645
        echo \$uptime
    else 
        # https://stackoverflow.com/questions/15329443/proc-uptime-in-mac-os-x
        boottime=\`sysctl -n kern.boottime | awk '{print \$4}' | sed 's/,//g'\`
        unixtime=\`date +%s\`
\x09    timeAgo=\$((\$unixtime - \$boottime))
\x09    echo \$timeAgo
    fi
  }

  function format_total_seconds() {
    timeAgo=\$1
    seconds1=\$((timeAgo % 86400));
    seconds=\$((seconds1 % 60));
    minutes1=\$((seconds1 / 60));
    minutes=\$((minutes1 % 60));
    hours=\$((minutes1 / 60));
    echo \"\$(format2digits \$hours):\$(format2digits \$minutes):\$(format2digits \$seconds)\"
  }

  function print_header() {
    global_seconds=\"\$(get_global_seconds)\"

    # zero is 0?
    stopwatch_file=\"\$(get_stopwatch_file_name)\"
    if [[ -s \"\$stopwatch_file\" ]]; then
      zero_seconds=\$(<\$stopwatch_file)
      global_seconds=\$((global_seconds-zero_seconds))
    fi
    
    uptime=\"\$(format_total_seconds \$global_seconds)\"

    black_circle='\x5CxE2\x5Cx97\x5Cx8f'
    white_circle='\x5CxE2\x5Cx97\x5Cx8b'
    # BUILD_DEFINITIONNAME
    # if [[ -z \"\$BUILD_DEFINITIONNAME\" ]]; then 
    if [[ -z \"\$SAY_COLORLESS\" ]]; then # skip colors for azure pipelines
      Blue='\x5C033[1;34m'; Gray='\x5C033[1;37m'; LightGreen='\x5C033[1;32m'; Yellow='\x5C033[1;33m'; RED='\x5C033[0;31m'; NC='\x5C033[0m'; LightGray='\x5C033[1;2m';
    fi
    hostname=\"\$(hostname 2>/dev/null)\"
    hostname=\"\${hostname:-\$HOSTNAME}\"
    printf \"\${Blue}\${black_circle} \${hostname}\${NC} \${LightGray}[\${uptime:-}]\${NC} \${LightGreen}\$1\${NC} \${Yellow}\"; echo -n \"\$2\"; printf \"\${NC}\x5Cn\";
    echo \"\${hostname} \${uptime:-} \$1 \$2\" >> \"/tmp/Said-by-\$(whoami).log\" 2>/dev/null 
  }

  function SayIt() { 
    counter_file=\"\$(get_counter_file_name)\"
    if [[ -e \"\$counter_file\" ]]; then counter=\$(< \"\$counter_file\"); else counter=1; fi
    print_header \"#\${counter}\" \"\$1\";
    counter=\$((counter+1));
    echo \$counter > \"\$counter_file\"
  }; 


if [[ \"\$1\" == \"--Reset-Stopwatch\" ]]; then
  echo \"\$(get_global_seconds)\" > \"\$(get_stopwatch_file_name)\"
  echo 1 > \"\$(get_counter_file_name)\"
  exit 0;
fi

SayIt \"\$@\"

" | sudo tee ${TARGET_DIR}/Say >/dev/null;
  if [[ -f ${TARGET_DIR}/Say ]]; then 
      chmod +x ${TARGET_DIR}/Say >/dev/null 2>&1 || sudo chmod +x ${TARGET_DIR}/Say
  	echo "OK: ${TARGET_DIR}/Say"; 
  else "Error: Unable to extract ${TARGET_DIR}/Say"; fi
else 
  echo "Skipping ${TARGET_DIR}/Say: directory does not exists"
fi


# Show-System-Stat
if [[ -d ${TARGET_DIR} ]]; then
  echo -e "#!/usr/bin/env bash
function uname_system() {
  cached_uname_system=\${cached_uname_system:-\$(uname -s)}
  echo \$cached_uname_system
}

function format_seconds() {
  local elapsed=\$1
  local days=\$((elapsed/86400))
  if [[ \"\$(uname_system)\" != Darwin ]]; then
     elapsed=\$(TZ=UTC date -d \"@\${elapsed}\" \"+%H:%M:%S\");
  else 
     elapsed=\$(TZ=UTC date -r \"\${elapsed}\" \"+%H:%M:%S\");
  fi
  if [[ \${days} -eq 0 ]]; then 
    echo \${elapsed}
  elif [[ \${days} -eq 1 ]]; then
    echo \"1 day, \$elapsed\"
  else
    echo \"\$days days, \$elapsed\"
  fi
}

function GetUptimeInSeconds() {
   local uptime=\$(</proc/uptime);                  # 42645.93 240538.58
   IFS=' ' read -ra uptime <<< \"\$uptime\";    # 42645.93 240538.58
   uptime=\"\${uptime[0]}\";                    # 42645.93
   uptime=\$(printf \"%.0f\x5Cn\" \"\$uptime\")       # 42645
   echo \$uptime
}

function format_label() {
    local label=\"\$1\"
    label=\"\${label} \";local n=0; while [[ \$n -lt 55 && \"\${#label}\" -lt 38 ]]; do n=\$((n+1));label=\"\${label}.\"; done
    echo \"\$label\"
}

function ShowSystemStat() {
  if [[ \"\$(uname_system)\" == Darwin || ! -f /proc/stat ]]; then
    uptime
    return;
  fi
  
  local first_line=\$(cat /proc/stat | sed -n 1p)
  local user_normal=\$(echo \$first_line | awk '{print \$2}')
  user_normal=\$((user_normal/100))
  local user_nice=\$(echo \$first_line | awk '{print \$3}')
  user_nice=\$((user_nice/100))
  local system=\$(echo \$first_line | awk '{print \$4}')
  system=\$((system/100))
  local total=\$((user_normal + user_nice + system))
  local uptime=\$(GetUptimeInSeconds)
  # echo uptime in seconds: \$uptime 
  
  local user_normal_formatted=\"\$(format_seconds \${user_normal})\"
  local user_nice_formatted=\"\$(format_seconds \${user_nice})\"
  local system_formatted=\"\$(format_seconds \${system})\"
  local total_formatted=\"\$(format_seconds \${total})\"
  local uptime_formatted=\"\$(format_seconds \${uptime})\"
  
  
  echo \"User CPU Usage (normal priority) ..... \$user_normal_formatted
User CPU Usage (low priority) ........ \$user_nice_formatted
System CPU Usage ..................... \$system_formatted
TOTAL CPU Usage ...................... \$total_formatted
Uptime ............................... \$uptime_formatted\"
}

function FormatBytes() {
    local bytes=\$1
    if [[ \"\$bytes\" -lt 9000 ]]; then bytes=\"\$bytes B\"; 
    elif [[ \"\$bytes\" -lt 9000000 ]]; then bytes=\$((bytes/1024)); bytes=\"\$bytes KB\";
    elif [[ \"\$bytes\" -lt 9000000000 ]]; then bytes=\$((bytes/1048576)); bytes=\"\$bytes MB\";
    elif [[ \"\$bytes\" -lt 9000000000000 ]]; then bytes=\$((bytes/1073741824)); bytes=\"\$bytes GB\";
    else bytes=\$((bytes/1099511627776)); bytes=\"\$bytes TB\";
    fi
    echo \$bytes
}

function ShowNetStat() {
    if [[ ! -f /proc/net/dev ]]; then return; fi
    local line
    cat /proc/net/dev | sed -n '3,\$p' | sort | while read line; do
        local name=\$(echo \$line | awk '{print \$1}')
        if [[ \"\$name\" == *\":\" ]]; then
            local recv=\$(echo \$line | awk '{print \$2}')
            local sent=\$(echo \$line | awk '{print \$10}')
            name=\$(format_label \"\$name\");
            if [[ \"\$sent\" -gt 0 && \"\$recv\" -gt 0 ]]; then
                sent=\$(FormatBytes \$sent)
                recv=\$(FormatBytes \$recv)
                local sent_formatted=\`printf %-7s \"\$sent\"\`
                local recv_formatted=\`printf %-7s \"\$recv\"\`
                echo \"\$name \${sent_formatted} [sent] + \${recv_formatted} [recieved]\"
            fi  
        fi 
    done
}

function parseStat() {
    # args: statDir, statTitle
    local size=\"\$(cat \$statDir/size 2>/dev/null)\"
    if [[ \"\$size\" != \"0\" && \"\$size\" != \"\" && \"\$size\" -gt 0 ]]; then
        local line=\"\$(cat \$statDir/stat)\";
        IO_MILLISECONDS=\$(echo \$line | awk '{print \$10}');
        READ_SECTORS=\$(echo \$line | awk '{print \$3}');
        WRITE_SECTORS=\$(echo \$line | awk '{print \$7}');
        if [[ \$IO_MILLISECONDS -gt 0 && \$READ_SECTORS -gt 0 && \$WRITE_SECTORS -gt 0 ]]; then
            local read=\$(FormatBytes \$((READ_SECTORS*512)))
            local wrote=\$(FormatBytes \$((WRITE_SECTORS*512)))
            local read_formatted=\`printf %-7s \"\$read\"\`
            local wrote_formatted=\`printf %-7s \"\$wrote\"\`
            local io_time_formatted=\$(format_seconds \$((IO_MILLISECONDS/1000)))
            local title_formatted=\$(format_label \"\$statTitle\")
            echo \"\$title_formatted \${wrote_formatted} [wrote] + \${read_formatted} [read], \${io_time_formatted} io\"
        fi 
    fi
}

function ShowBlockStat() {
    local blockDirs=\$(ls -1 /sys/block 2>/dev/null);
    for blockDirName in \$blockDirs; do
        local blockDir=/sys/block/\$blockDirName
        if [[ -d \$blockDir ]]; then
            statDir=\"\${blockDir}\";
            statTitle=\"/dev/\$(basename \$blockDir)\";
            parseStat
            volDirs=\$(ls -1 \$blockDir 2>/dev/null);
            for volDirName in \$volDirs; do
                local volDir=\"\$blockDir/\$volDirName\"
                # echo \"VOL: \$volDir\" 
                if [[ -d \$volDir ]]; then
                    statDir=\"\${volDir}\";
                    statTitle=\" --- \$(basename \$volDirName)\";
                    parseStat
                fi 
            done 
        fi
    done;
    
}

# while true; do clear; ShowSystemStat; sleep 2; done
ShowSystemStat
echo \"------------NETWORK-------------------\"
ShowNetStat
echo \"------------DISKS---------------------\"
ShowBlockStat

" 2>/dev/null >${TARGET_DIR}/Show-System-Stat ||
  echo -e "#!/usr/bin/env bash
function uname_system() {
  cached_uname_system=\${cached_uname_system:-\$(uname -s)}
  echo \$cached_uname_system
}

function format_seconds() {
  local elapsed=\$1
  local days=\$((elapsed/86400))
  if [[ \"\$(uname_system)\" != Darwin ]]; then
     elapsed=\$(TZ=UTC date -d \"@\${elapsed}\" \"+%H:%M:%S\");
  else 
     elapsed=\$(TZ=UTC date -r \"\${elapsed}\" \"+%H:%M:%S\");
  fi
  if [[ \${days} -eq 0 ]]; then 
    echo \${elapsed}
  elif [[ \${days} -eq 1 ]]; then
    echo \"1 day, \$elapsed\"
  else
    echo \"\$days days, \$elapsed\"
  fi
}

function GetUptimeInSeconds() {
   local uptime=\$(</proc/uptime);                  # 42645.93 240538.58
   IFS=' ' read -ra uptime <<< \"\$uptime\";    # 42645.93 240538.58
   uptime=\"\${uptime[0]}\";                    # 42645.93
   uptime=\$(printf \"%.0f\x5Cn\" \"\$uptime\")       # 42645
   echo \$uptime
}

function format_label() {
    local label=\"\$1\"
    label=\"\${label} \";local n=0; while [[ \$n -lt 55 && \"\${#label}\" -lt 38 ]]; do n=\$((n+1));label=\"\${label}.\"; done
    echo \"\$label\"
}

function ShowSystemStat() {
  if [[ \"\$(uname_system)\" == Darwin || ! -f /proc/stat ]]; then
    uptime
    return;
  fi
  
  local first_line=\$(cat /proc/stat | sed -n 1p)
  local user_normal=\$(echo \$first_line | awk '{print \$2}')
  user_normal=\$((user_normal/100))
  local user_nice=\$(echo \$first_line | awk '{print \$3}')
  user_nice=\$((user_nice/100))
  local system=\$(echo \$first_line | awk '{print \$4}')
  system=\$((system/100))
  local total=\$((user_normal + user_nice + system))
  local uptime=\$(GetUptimeInSeconds)
  # echo uptime in seconds: \$uptime 
  
  local user_normal_formatted=\"\$(format_seconds \${user_normal})\"
  local user_nice_formatted=\"\$(format_seconds \${user_nice})\"
  local system_formatted=\"\$(format_seconds \${system})\"
  local total_formatted=\"\$(format_seconds \${total})\"
  local uptime_formatted=\"\$(format_seconds \${uptime})\"
  
  
  echo \"User CPU Usage (normal priority) ..... \$user_normal_formatted
User CPU Usage (low priority) ........ \$user_nice_formatted
System CPU Usage ..................... \$system_formatted
TOTAL CPU Usage ...................... \$total_formatted
Uptime ............................... \$uptime_formatted\"
}

function FormatBytes() {
    local bytes=\$1
    if [[ \"\$bytes\" -lt 9000 ]]; then bytes=\"\$bytes B\"; 
    elif [[ \"\$bytes\" -lt 9000000 ]]; then bytes=\$((bytes/1024)); bytes=\"\$bytes KB\";
    elif [[ \"\$bytes\" -lt 9000000000 ]]; then bytes=\$((bytes/1048576)); bytes=\"\$bytes MB\";
    elif [[ \"\$bytes\" -lt 9000000000000 ]]; then bytes=\$((bytes/1073741824)); bytes=\"\$bytes GB\";
    else bytes=\$((bytes/1099511627776)); bytes=\"\$bytes TB\";
    fi
    echo \$bytes
}

function ShowNetStat() {
    if [[ ! -f /proc/net/dev ]]; then return; fi
    local line
    cat /proc/net/dev | sed -n '3,\$p' | sort | while read line; do
        local name=\$(echo \$line | awk '{print \$1}')
        if [[ \"\$name\" == *\":\" ]]; then
            local recv=\$(echo \$line | awk '{print \$2}')
            local sent=\$(echo \$line | awk '{print \$10}')
            name=\$(format_label \"\$name\");
            if [[ \"\$sent\" -gt 0 && \"\$recv\" -gt 0 ]]; then
                sent=\$(FormatBytes \$sent)
                recv=\$(FormatBytes \$recv)
                local sent_formatted=\`printf %-7s \"\$sent\"\`
                local recv_formatted=\`printf %-7s \"\$recv\"\`
                echo \"\$name \${sent_formatted} [sent] + \${recv_formatted} [recieved]\"
            fi  
        fi 
    done
}

function parseStat() {
    # args: statDir, statTitle
    local size=\"\$(cat \$statDir/size 2>/dev/null)\"
    if [[ \"\$size\" != \"0\" && \"\$size\" != \"\" && \"\$size\" -gt 0 ]]; then
        local line=\"\$(cat \$statDir/stat)\";
        IO_MILLISECONDS=\$(echo \$line | awk '{print \$10}');
        READ_SECTORS=\$(echo \$line | awk '{print \$3}');
        WRITE_SECTORS=\$(echo \$line | awk '{print \$7}');
        if [[ \$IO_MILLISECONDS -gt 0 && \$READ_SECTORS -gt 0 && \$WRITE_SECTORS -gt 0 ]]; then
            local read=\$(FormatBytes \$((READ_SECTORS*512)))
            local wrote=\$(FormatBytes \$((WRITE_SECTORS*512)))
            local read_formatted=\`printf %-7s \"\$read\"\`
            local wrote_formatted=\`printf %-7s \"\$wrote\"\`
            local io_time_formatted=\$(format_seconds \$((IO_MILLISECONDS/1000)))
            local title_formatted=\$(format_label \"\$statTitle\")
            echo \"\$title_formatted \${wrote_formatted} [wrote] + \${read_formatted} [read], \${io_time_formatted} io\"
        fi 
    fi
}

function ShowBlockStat() {
    local blockDirs=\$(ls -1 /sys/block 2>/dev/null);
    for blockDirName in \$blockDirs; do
        local blockDir=/sys/block/\$blockDirName
        if [[ -d \$blockDir ]]; then
            statDir=\"\${blockDir}\";
            statTitle=\"/dev/\$(basename \$blockDir)\";
            parseStat
            volDirs=\$(ls -1 \$blockDir 2>/dev/null);
            for volDirName in \$volDirs; do
                local volDir=\"\$blockDir/\$volDirName\"
                # echo \"VOL: \$volDir\" 
                if [[ -d \$volDir ]]; then
                    statDir=\"\${volDir}\";
                    statTitle=\" --- \$(basename \$volDirName)\";
                    parseStat
                fi 
            done 
        fi
    done;
    
}

# while true; do clear; ShowSystemStat; sleep 2; done
ShowSystemStat
echo \"------------NETWORK-------------------\"
ShowNetStat
echo \"------------DISKS---------------------\"
ShowBlockStat

" | sudo tee ${TARGET_DIR}/Show-System-Stat >/dev/null;
  if [[ -f ${TARGET_DIR}/Show-System-Stat ]]; then 
      chmod +x ${TARGET_DIR}/Show-System-Stat >/dev/null 2>&1 || sudo chmod +x ${TARGET_DIR}/Show-System-Stat
  	echo "OK: ${TARGET_DIR}/Show-System-Stat"; 
  else "Error: Unable to extract ${TARGET_DIR}/Show-System-Stat"; fi
else 
  echo "Skipping ${TARGET_DIR}/Show-System-Stat: directory does not exists"
fi


# smart-apt-install
if [[ -d ${TARGET_DIR} ]]; then
  echo -e "#!/usr/bin/env bash

    try-and-retry lazy-apt-update
    Say \"Downloading deb-package(s): \$*\"
    try-and-retry sudo apt-get -qq -d --allow-unauthenticated install \"\$@\" 
    Say \"Installing deb-package(s): \$*\"
    sudo DEBIAN_FRONTEND=noninteractive apt-get --allow-unauthenticated install \"\$@\" -y -q
    sudo DEBIAN_FRONTEND=noninteractive apt-get clean

" 2>/dev/null >${TARGET_DIR}/smart-apt-install ||
  echo -e "#!/usr/bin/env bash

    try-and-retry lazy-apt-update
    Say \"Downloading deb-package(s): \$*\"
    try-and-retry sudo apt-get -qq -d --allow-unauthenticated install \"\$@\" 
    Say \"Installing deb-package(s): \$*\"
    sudo DEBIAN_FRONTEND=noninteractive apt-get --allow-unauthenticated install \"\$@\" -y -q
    sudo DEBIAN_FRONTEND=noninteractive apt-get clean

" | sudo tee ${TARGET_DIR}/smart-apt-install >/dev/null;
  if [[ -f ${TARGET_DIR}/smart-apt-install ]]; then 
      chmod +x ${TARGET_DIR}/smart-apt-install >/dev/null 2>&1 || sudo chmod +x ${TARGET_DIR}/smart-apt-install
  	echo "OK: ${TARGET_DIR}/smart-apt-install"; 
  else "Error: Unable to extract ${TARGET_DIR}/smart-apt-install"; fi
else 
  echo "Skipping ${TARGET_DIR}/smart-apt-install: directory does not exists"
fi


# try-and-retry
if [[ -d ${TARGET_DIR} ]]; then
  echo -e "#!/usr/bin/env bash

  ANSI_RED='\x5C033[0;31m'; 
  ANSI_RESET='\x5C033[0m';
  result=0
  count=1
  while [ \$count -le 3 ]; do
    [ \$result -ne 0 ] && {
      echo -e \"\x5Cn\${ANSI_RED}The command \x5C\"\$@\x5C\" failed. Retrying, \$count of 3.\${ANSI_RESET}\x5Cn\" >&2
    }
    # ! { } ignores set -e, see https://stackoverflow.com/a/4073372
    ! { \"\$@\"; result=\$?; }
    [ \$result -eq 0 ] && break
    count=\$((\$count + 1))
    sleep 1
  done

  [ \$count -gt 3 ] && {
    echo -e \"\x5Cn\${ANSI_RED}The command \x5C\"\$@\x5C\" failed 3 times.\${ANSI_RESET}\x5Cn\" >&2
  }

  exit \$result



" 2>/dev/null >${TARGET_DIR}/try-and-retry ||
  echo -e "#!/usr/bin/env bash

  ANSI_RED='\x5C033[0;31m'; 
  ANSI_RESET='\x5C033[0m';
  result=0
  count=1
  while [ \$count -le 3 ]; do
    [ \$result -ne 0 ] && {
      echo -e \"\x5Cn\${ANSI_RED}The command \x5C\"\$@\x5C\" failed. Retrying, \$count of 3.\${ANSI_RESET}\x5Cn\" >&2
    }
    # ! { } ignores set -e, see https://stackoverflow.com/a/4073372
    ! { \"\$@\"; result=\$?; }
    [ \$result -eq 0 ] && break
    count=\$((\$count + 1))
    sleep 1
  done

  [ \$count -gt 3 ] && {
    echo -e \"\x5Cn\${ANSI_RED}The command \x5C\"\$@\x5C\" failed 3 times.\${ANSI_RESET}\x5Cn\" >&2
  }

  exit \$result



" | sudo tee ${TARGET_DIR}/try-and-retry >/dev/null;
  if [[ -f ${TARGET_DIR}/try-and-retry ]]; then 
      chmod +x ${TARGET_DIR}/try-and-retry >/dev/null 2>&1 || sudo chmod +x ${TARGET_DIR}/try-and-retry
  	echo "OK: ${TARGET_DIR}/try-and-retry"; 
  else "Error: Unable to extract ${TARGET_DIR}/try-and-retry"; fi
else 
  echo "Skipping ${TARGET_DIR}/try-and-retry: directory does not exists"
fi


}
install_build_tools_bundle

