$ErrorActionPreference = "Stop"

Write-Host '#!/usr/bin/env bash
# This file is autogenerated by lab/permanent-scripts/pack. Usage:
# for termux: export TARGET_DIR=$PREFIX/bin, otherwise /usr/local/bin
# script=https://raw.githubusercontent.com/devizer/test-and-build/master/install-build-tools-bundle.sh; (wget -q -nv --no-check-certificate -O - $script 2>/dev/null || curl -ksSL $script) | bash

if [[ -z "${TARGET_DIR:-}" ]]; then
  defult_target_dir=/usr/local/bin
  if [[ -n "${TERMUX_VERSION}" ]] && [[ -n "${PREFIX}" ]] && [[ -d "${PREFIX}" ]]; then
    defult_target_dir="$PREFIX/bin"
  fi

  if [[ "$(uname -s)" == *"MINGW"* ]] && [[ -d "C:\\Windows" ]]; then
    defult_target_dir="C:\\Windows"
  fi

  TARGET_DIR="$defult_target_dir"
fi

echo "Installing Say, try-and-retry, Get-GitHub-Latest-Releasem etc into [${TARGET_DIR}]"

function install_build_tools_bundle() {
'

function ReadAllLines
{
    param([System.String] $fileName)

    $ret = @();
    $utf = new-object System.Text.UTF8Encoding($false)
    $fs = new-object System.IO.FileStream($fileName, [System.IO.FileMode]::Open)
    $rdr = new-object System.IO.StreamReader($fs, $utf)
    while($true) {
        $line=$rdr.ReadLine()
        if (($line -eq $null))
        {
            $rdr.Dispose()
            return $ret
        }
        $ret += $line
    }
}

 

 

function EscapeFile2Echo
{
    param([System.String] $fileName)

    $ret = ""
    # $lines = [System.IO.File]::ReadAllLines($fileName)
    $lines = ReadAllLines $fileName
   	$nameOnly=[System.IO.Path]::GetFileNameWithoutExtension($fileName)

    foreach ($line in $lines)
    {
        foreach ($c in $line.ToCharArray())
        {
            $ic=[int]$c;
            if ( $ic -eq 96 -or $ic -eq 34 -or $ic -eq 36)
            {
                $ret = [System.String]::Concat(@($ret, "\", $c.ToString()))
            }
            elseif ($ic -eq 92 -or $ic -lt 32)
            {
                $ret = [System.String]::Concat(@($ret, "\x", [string]::Format("{0:X2}", [int]$c)))
            }
            else
            {
                $ret = [System.String]::Concat(@($ret, $c.ToString()))
            }
        }
        $ret = [System.String]::Concat(@($ret, [Environment]::NewLine))
    }
    return $ret
}

function WriteFile
{
    param([System.String] $fileName)

   	$nameOnly=[System.IO.Path]::GetFileNameWithoutExtension($fileName)
    $escaped = EscapeFile2Echo $fileName
    $nl=[Environment]::NewLine
    $escaped_and_Queted="`"$($escaped)$($nl)`""
    $ret = "
# $($nameOnly)
if [[ -d `${TARGET_DIR} ]]; then
  echo -e $($escaped_and_Queted) 2>/dev/null >`${TARGET_DIR}/$($nameOnly) ||
  echo -e $($escaped_and_Queted) | sudo tee `${TARGET_DIR}/$($nameOnly) >/dev/null;
  if [[ -f `${TARGET_DIR}/$($nameOnly) ]]; then 
      chmod +x `${TARGET_DIR}/$($nameOnly) >/dev/null 2>&1 || sudo chmod +x `${TARGET_DIR}/$($nameOnly)
  	echo `"OK: `${TARGET_DIR}/$($nameOnly)`"; 
  else `"Error: Unable to extract `${TARGET_DIR}/$($nameOnly)`" >&2; fi
else 
  echo `"Skipping `${TARGET_DIR}/$($nameOnly): directory does not exists`" >&2
fi
"

	return $ret
}
 

Get-ChildItem -Path ../ -Filter *.sh -File | ForEach-Object {
    $_.FullName
} | ForEach-Object {
	$nameOnly=[System.IO.Path]::GetFileNameWithoutExtension($_)
	$content=Get-Content "$_"
	"$(WriteFile $_)"
}

"
}
install_build_tools_bundle
"